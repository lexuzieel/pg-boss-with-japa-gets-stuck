{"version":3,"file":"index.mjs","names":["plans.assertMigration","plans.setVersion","plans.locked","plans.DEFAULT_SCHEMA","plans.create","migrationStore.migrate","migrationStore.rollback","migrationStore.getAll","plans.getVersion","plans.versionTableExists","err: any","plans.CREATE_RACE_MESSAGE","plans.MIGRATE_RACE_MESSAGE","migrationStore.next","WARNINGS","plans.getTime","plans.trySetCronTime","plans.getSchedules","params: unknown[]","plans.getSchedulesByQueue","plans.schedule","err: any","plans.unschedule","err: any","timekeeper.QUEUES","events","error: any","Attorney.checkWorkArgs","err: any","Worker","plans.subscribe","plans.unsubscribe","plans.getQueuesForEvent","Attorney.checkSendArgs","plans.insertJobs","plans.fetchNextJob","stringify","plans.completeJobs","plans.failJobsById","plans.cancelJobs","plans.deleteJobsById","plans.resumeJobs","plans.retryJobs","plans.QUEUE_POLICIES","plans.createQueue","plans.getQueues","plans.updateQueue","plans.deleteQueue","plans.deleteQueuedJobs","plans.deleteStoredJobs","plans.truncateTable","plans.deleteAllJobs","plans.getQueueStats","plans.getJobById","events","#db","#config","#manager","#stopped","#superviseInterval","#onSupervise","#executeSql","#maintaining","queues","#monitor","#maintain","plans.trySetQueueMonitorTime","plans.cacheQueueStats","plans.failJobsByTimeout","plans.trySetQueueDeletionTime","plans.deletion","events: types.Events","Contractor","#stoppingOn","#stopped","Attorney.getConfig","#config","db: (types.IDatabase & { _pgbdb?: false }) | DbDefault","#db","#promoteEvents","Manager","Boss","Timekeeper","#boss","#contractor","#manager","#timekeeper","#starting","#started","DbDefault"],"sources":["../src/plans.ts","../src/attorney.ts","../src/migrationStore.ts","../package.json","../src/contractor.ts","../src/timekeeper.ts","../src/tools.ts","../src/worker.ts","../src/manager.ts","../src/boss.ts","../src/db.ts","../src/index.ts"],"sourcesContent":["import type { UpdateQueueOptions } from './types.ts'\n\nconst DEFAULT_SCHEMA = 'pgboss'\nconst MIGRATE_RACE_MESSAGE = 'division by zero'\nconst CREATE_RACE_MESSAGE = 'already exists'\nconst FIFTEEN_MINUTES = 60 * 15\nconst FORTEEN_DAYS = 60 * 60 * 24 * 14\nconst SEVEN_DAYS = 60 * 60 * 24 * 7\n\nconst JOB_STATES = Object.freeze({\n  created: 'created',\n  retry: 'retry',\n  active: 'active',\n  completed: 'completed',\n  cancelled: 'cancelled',\n  failed: 'failed'\n})\n\nconst QUEUE_POLICIES = Object.freeze({\n  standard: 'standard',\n  short: 'short',\n  singleton: 'singleton',\n  stately: 'stately',\n  exclusive: 'exclusive'\n})\n\nconst QUEUE_DEFAULTS = {\n  expire_seconds: FIFTEEN_MINUTES,\n  retention_seconds: FORTEEN_DAYS,\n  deletion_seconds: SEVEN_DAYS,\n  retry_limit: 2,\n  retry_delay: 0,\n  warning_queued: 0,\n  retry_backoff: false,\n  partition: false\n}\n\nconst COMMON_JOB_TABLE = 'job_common'\n\nfunction create (schema: string, version: number, options?: { createSchema?: boolean }) {\n  const commands = [\n    options?.createSchema ? createSchema(schema) : '',\n    createEnumJobState(schema),\n\n    createTableVersion(schema),\n    createTableQueue(schema),\n    createTableSchedule(schema),\n    createTableSubscription(schema),\n\n    createTableJob(schema),\n    createPrimaryKeyJob(schema),\n    createTableJobCommon(schema, COMMON_JOB_TABLE),\n\n    createQueueFunction(schema),\n    deleteQueueFunction(schema),\n\n    insertVersion(schema, version)\n  ]\n\n  return locked(schema, commands)\n}\n\nfunction createSchema (schema: string) {\n  return `CREATE SCHEMA IF NOT EXISTS ${schema}`\n}\n\nfunction createEnumJobState (schema: string) {\n  // ENUM definition order is important\n  // base type is numeric and first values are less than last values\n  return `\n    CREATE TYPE ${schema}.job_state AS ENUM (\n      '${JOB_STATES.created}',\n      '${JOB_STATES.retry}',\n      '${JOB_STATES.active}',\n      '${JOB_STATES.completed}',\n      '${JOB_STATES.cancelled}',\n      '${JOB_STATES.failed}'\n    )\n  `\n}\n\nfunction createTableVersion (schema: string) {\n  return `\n    CREATE TABLE ${schema}.version (\n      version int primary key,\n      cron_on timestamp with time zone\n    )\n  `\n}\n\nfunction createTableQueue (schema: string) {\n  return `\n    CREATE TABLE ${schema}.queue (\n      name text NOT NULL,\n      policy text NOT NULL,\n      retry_limit int NOT NULL,\n      retry_delay int NOT NULL,\n      retry_backoff bool NOT NULL,\n      retry_delay_max int,\n      expire_seconds int NOT NULL,\n      retention_seconds int NOT NULL,\n      deletion_seconds int NOT NULL,\n      dead_letter text REFERENCES ${schema}.queue (name) CHECK (dead_letter IS DISTINCT FROM name),\n      partition bool NOT NULL,\n      table_name text NOT NULL,\n      deferred_count int NOT NULL default 0,\n      queued_count int NOT NULL default 0,\n      warning_queued int NOT NULL default 0,\n      active_count int NOT NULL default 0,\n      total_count int NOT NULL default 0,\n      singletons_active text[],\n      monitor_on timestamp with time zone,\n      maintain_on timestamp with time zone,\n      created_on timestamp with time zone not null default now(),\n      updated_on timestamp with time zone not null default now(),\n      PRIMARY KEY (name)\n    )\n  `\n}\n\nfunction createTableSchedule (schema: string) {\n  return `\n    CREATE TABLE ${schema}.schedule (\n      name text REFERENCES ${schema}.queue ON DELETE CASCADE,\n      key text not null DEFAULT '',\n      cron text not null,\n      timezone text,\n      data jsonb,\n      options jsonb,\n      created_on timestamp with time zone not null default now(),\n      updated_on timestamp with time zone not null default now(),\n      PRIMARY KEY (name, key)\n    )\n  `\n}\n\nfunction createTableSubscription (schema: string) {\n  return `\n    CREATE TABLE ${schema}.subscription (\n      event text not null,\n      name text not null REFERENCES ${schema}.queue ON DELETE CASCADE,\n      created_on timestamp with time zone not null default now(),\n      updated_on timestamp with time zone not null default now(),\n      PRIMARY KEY(event, name)\n    )\n  `\n}\n\nfunction createTableJob (schema: string) {\n  return `\n    CREATE TABLE ${schema}.job (\n      id uuid not null default gen_random_uuid(),\n      name text not null,\n      priority integer not null default(0),\n      data jsonb,\n      state ${schema}.job_state not null default '${JOB_STATES.created}',\n      retry_limit integer not null default ${QUEUE_DEFAULTS.retry_limit},\n      retry_count integer not null default 0,\n      retry_delay integer not null default ${QUEUE_DEFAULTS.retry_delay},\n      retry_backoff boolean not null default ${QUEUE_DEFAULTS.retry_backoff},\n      retry_delay_max integer,\n      expire_seconds int not null default ${QUEUE_DEFAULTS.expire_seconds},\n      deletion_seconds int not null default ${QUEUE_DEFAULTS.deletion_seconds},\n      singleton_key text,\n      singleton_on timestamp without time zone,\n      start_after timestamp with time zone not null default now(),\n      created_on timestamp with time zone not null default now(),\n      started_on timestamp with time zone,\n      completed_on timestamp with time zone,\n      keep_until timestamp with time zone NOT NULL default now() + interval '${QUEUE_DEFAULTS.retention_seconds}',\n      output jsonb,\n      dead_letter text,\n      policy text\n    ) PARTITION BY LIST (name)\n  `\n}\n\nconst JOB_COLUMNS_MIN = 'id, name, data, expire_seconds as \"expireInSeconds\"'\nconst JOB_COLUMNS_ALL = `${JOB_COLUMNS_MIN},\n  policy,\n  state,\n  priority,\n  retry_limit as \"retryLimit\",\n  retry_count as \"retryCount\",\n  retry_delay as \"retryDelay\",\n  retry_backoff as \"retryBackoff\",\n  retry_delay_max as \"retryDelayMax\",\n  start_after as \"startAfter\",\n  started_on as \"startedOn\",\n  singleton_key as \"singletonKey\",\n  singleton_on as \"singletonOn\",\n  deletion_seconds as \"deleteAfterSeconds\",\n  created_on as \"createdOn\",\n  completed_on as \"completedOn\",\n  keep_until as \"keepUntil\",\n  dead_letter as \"deadLetter\",\n  output\n`\n\nfunction createTableJobCommon (schema: string, table: string) {\n  const format = (command: string) => command.replaceAll('.job', `.${table}`) + ';'\n\n  return `\n    CREATE TABLE ${schema}.${table} (LIKE ${schema}.job INCLUDING GENERATED INCLUDING DEFAULTS);\n    ${format(createPrimaryKeyJob(schema))}\n    ${format(createQueueForeignKeyJob(schema))}\n    ${format(createQueueForeignKeyJobDeadLetter(schema))}\n    ${format(createIndexJobPolicyShort(schema))}\n    ${format(createIndexJobPolicySingleton(schema))}\n    ${format(createIndexJobPolicyStately(schema))}\n    ${format(createIndexJobPolicyExclusive(schema))}\n    ${format(createIndexJobThrottle(schema))}\n    ${format(createIndexJobFetch(schema))}\n\n    ALTER TABLE ${schema}.job ATTACH PARTITION ${schema}.${table} DEFAULT;\n  `\n}\n\nfunction createQueueFunction (schema: string) {\n  return `\n    CREATE FUNCTION ${schema}.create_queue(queue_name text, options jsonb)\n    RETURNS VOID AS\n    $$\n    DECLARE\n      tablename varchar := CASE WHEN options->>'partition' = 'true'\n                            THEN 'j' || encode(sha224(queue_name::bytea), 'hex')\n                            ELSE '${COMMON_JOB_TABLE}'\n                            END;\n      queue_created_on timestamptz;\n    BEGIN\n\n      WITH q as (\n        INSERT INTO ${schema}.queue (\n          name,\n          policy,\n          retry_limit,\n          retry_delay,\n          retry_backoff,\n          retry_delay_max,\n          expire_seconds,\n          retention_seconds,\n          deletion_seconds,\n          warning_queued,\n          dead_letter,\n          partition,\n          table_name\n        )\n        VALUES (\n          queue_name,\n          options->>'policy',\n          COALESCE((options->>'retryLimit')::int, ${QUEUE_DEFAULTS.retry_limit}),\n          COALESCE((options->>'retryDelay')::int, ${QUEUE_DEFAULTS.retry_delay}),\n          COALESCE((options->>'retryBackoff')::bool, ${QUEUE_DEFAULTS.retry_backoff}),\n          (options->>'retryDelayMax')::int,\n          COALESCE((options->>'expireInSeconds')::int, ${QUEUE_DEFAULTS.expire_seconds}),\n          COALESCE((options->>'retentionSeconds')::int, ${QUEUE_DEFAULTS.retention_seconds}),\n          COALESCE((options->>'deleteAfterSeconds')::int, ${QUEUE_DEFAULTS.deletion_seconds}),\n          COALESCE((options->>'warningQueueSize')::int, ${QUEUE_DEFAULTS.warning_queued}),\n          options->>'deadLetter',\n          COALESCE((options->>'partition')::bool, ${QUEUE_DEFAULTS.partition}),\n          tablename\n        )\n        ON CONFLICT DO NOTHING\n        RETURNING created_on\n      )\n      SELECT created_on into queue_created_on from q;\n\n      IF queue_created_on IS NULL OR options->>'partition' IS DISTINCT FROM 'true' THEN\n        RETURN;\n      END IF;\n\n      EXECUTE format('CREATE TABLE ${schema}.%I (LIKE ${schema}.job INCLUDING DEFAULTS)', tablename);\n      \n      EXECUTE format('${formatPartitionCommand(createPrimaryKeyJob(schema))}', tablename);\n      EXECUTE format('${formatPartitionCommand(createQueueForeignKeyJob(schema))}', tablename);\n      EXECUTE format('${formatPartitionCommand(createQueueForeignKeyJobDeadLetter(schema))}', tablename);\n\n      EXECUTE format('${formatPartitionCommand(createIndexJobFetch(schema))}', tablename);\n      EXECUTE format('${formatPartitionCommand(createIndexJobThrottle(schema))}', tablename);\n      \n      IF options->>'policy' = 'short' THEN\n        EXECUTE format('${formatPartitionCommand(createIndexJobPolicyShort(schema))}', tablename);\n      ELSIF options->>'policy' = 'singleton' THEN\n        EXECUTE format('${formatPartitionCommand(createIndexJobPolicySingleton(schema))}', tablename);\n      ELSIF options->>'policy' = 'stately' THEN\n        EXECUTE format('${formatPartitionCommand(createIndexJobPolicyStately(schema))}', tablename);\n      ELSIF options->>'policy' = 'exclusive' THEN\n        EXECUTE format('${formatPartitionCommand(createIndexJobPolicyExclusive(schema))}', tablename);\n      END IF;\n\n      EXECUTE format('ALTER TABLE ${schema}.%I ADD CONSTRAINT cjc CHECK (name=%L)', tablename, queue_name);\n      EXECUTE format('ALTER TABLE ${schema}.job ATTACH PARTITION ${schema}.%I FOR VALUES IN (%L)', tablename, queue_name);\n    END;\n    $$\n    LANGUAGE plpgsql;\n  `\n}\n\nfunction formatPartitionCommand (command: string) {\n  return command\n    .replace('.job', '.%1$I')\n    .replace('job_i', '%1$s_i')\n    .replaceAll(\"'\", \"''\")\n}\n\nfunction deleteQueueFunction (schema: string) {\n  return `\n    CREATE FUNCTION ${schema}.delete_queue(queue_name text)\n    RETURNS VOID AS\n    $$\n    DECLARE\n      v_table varchar;\n      v_partition bool;\n    BEGIN\n      SELECT table_name, partition\n      FROM ${schema}.queue\n      WHERE name = queue_name\n      INTO v_table, v_partition;\n\n      IF v_partition THEN\n        EXECUTE format('DROP TABLE IF EXISTS ${schema}.%I', v_table);\n      ELSE\n        EXECUTE format('DELETE FROM ${schema}.%I WHERE name = %L', v_table, queue_name);\n      END IF;\n\n      DELETE FROM ${schema}.queue WHERE name = queue_name;\n    END;\n    $$\n    LANGUAGE plpgsql;\n  `\n}\n\nfunction createQueue (schema: string, name: string, options: unknown) {\n  const sql = `SELECT ${schema}.create_queue('${name}', '${JSON.stringify(options)}'::jsonb)`\n  return locked(schema, sql, 'create-queue')\n}\n\nfunction deleteQueue (schema: string, name: string) {\n  const sql = `SELECT ${schema}.delete_queue('${name}')`\n  return locked(schema, sql, 'delete-queue')\n}\n\nfunction createPrimaryKeyJob (schema: string) {\n  return `ALTER TABLE ${schema}.job ADD PRIMARY KEY (name, id)`\n}\n\nfunction createQueueForeignKeyJob (schema: string) {\n  return `ALTER TABLE ${schema}.job ADD CONSTRAINT q_fkey FOREIGN KEY (name) REFERENCES ${schema}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED`\n}\n\nfunction createQueueForeignKeyJobDeadLetter (schema: string) {\n  return `ALTER TABLE ${schema}.job ADD CONSTRAINT dlq_fkey FOREIGN KEY (dead_letter) REFERENCES ${schema}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED`\n}\n\nfunction createIndexJobPolicyShort (schema: string) {\n  return `CREATE UNIQUE INDEX job_i1 ON ${schema}.job (name, COALESCE(singleton_key, '')) WHERE state = '${JOB_STATES.created}' AND policy = '${QUEUE_POLICIES.short}'`\n}\n\nfunction createIndexJobPolicySingleton (schema: string) {\n  return `CREATE UNIQUE INDEX job_i2 ON ${schema}.job (name, COALESCE(singleton_key, '')) WHERE state = '${JOB_STATES.active}' AND policy = '${QUEUE_POLICIES.singleton}'`\n}\n\nfunction createIndexJobPolicyStately (schema: string) {\n  return `CREATE UNIQUE INDEX job_i3 ON ${schema}.job (name, state, COALESCE(singleton_key, '')) WHERE state <= '${JOB_STATES.active}' AND policy = '${QUEUE_POLICIES.stately}'`\n}\n\nfunction createIndexJobThrottle (schema: string) {\n  return `CREATE UNIQUE INDEX job_i4 ON ${schema}.job (name, singleton_on, COALESCE(singleton_key, '')) WHERE state <> '${JOB_STATES.cancelled}' AND singleton_on IS NOT NULL`\n}\n\nfunction createIndexJobFetch (schema: string) {\n  return `CREATE INDEX job_i5 ON ${schema}.job (name, start_after) INCLUDE (priority, created_on, id) WHERE state < '${JOB_STATES.active}'`\n}\n\nfunction createIndexJobPolicyExclusive (schema: string) {\n  return `CREATE UNIQUE INDEX job_i6 ON ${schema}.job (name, COALESCE(singleton_key, '')) WHERE state <= '${JOB_STATES.active}' AND policy = '${QUEUE_POLICIES.exclusive}'`\n}\n\nfunction trySetQueueMonitorTime (schema: string, queues: string[], seconds: number) {\n  return trySetQueueTimestamp(schema, queues, 'monitor_on', seconds)\n}\n\nfunction trySetQueueDeletionTime (schema: string, queues: string[], seconds: number) {\n  return trySetQueueTimestamp(schema, queues, 'maintain_on', seconds)\n}\n\nfunction trySetCronTime (schema: string, seconds: number) {\n  return trySetTimestamp(schema, 'cron_on', seconds)\n}\n\nfunction trySetTimestamp (schema: string, column: string, seconds: number) {\n  return `\n    UPDATE ${schema}.version\n    SET ${column} = now()\n    WHERE EXTRACT( EPOCH FROM (now() - COALESCE(${column}, now() - interval '1 week') ) ) > ${seconds}\n    RETURNING true\n  `\n}\n\nfunction trySetQueueTimestamp (schema: string, queues: string[], column: string, seconds: number) {\n  return `\n    UPDATE ${schema}.queue\n    SET ${column} = now()\n    WHERE name IN(${getQueueInClause(queues)})\n      AND EXTRACT( EPOCH FROM (now() - COALESCE(${column}, now() - interval '1 week') ) ) > ${seconds}\n    RETURNING name    \n  `\n}\n\nfunction updateQueue (schema: string, { deadLetter }: UpdateQueueOptions = {}) {\n  return `\n    WITH options as (SELECT $2::jsonb as data)\n    UPDATE ${schema}.queue SET\n      retry_limit = COALESCE((o.data->>'retryLimit')::int, retry_limit),\n      retry_delay = COALESCE((o.data->>'retryDelay')::int, retry_delay),\n      retry_backoff = COALESCE((o.data->>'retryBackoff')::bool, retry_backoff),\n      retry_delay_max = CASE WHEN o.data ? 'retryDelayMax'\n        THEN (o.data->>'retryDelayMax')::int\n        ELSE retry_delay_max END,\n      expire_seconds = COALESCE((o.data->>'expireInSeconds')::int, expire_seconds),\n      retention_seconds = COALESCE((o.data->>'retentionSeconds')::int, retention_seconds),\n      deletion_seconds = COALESCE((o.data->>'deleteAfterSeconds')::int, deletion_seconds),\n      warning_queued = COALESCE((o.data->>'warningQueueSize')::int, warning_queued),\n      ${\n        deadLetter === undefined\n          ? ''\n          : `dead_letter = CASE WHEN '${deadLetter}' IS DISTINCT FROM dead_letter THEN '${deadLetter}' ELSE dead_letter END,`\n      }\n      updated_on = now()\n    FROM options o\n    WHERE name = $1\n  `\n}\n\nfunction getQueues (schema: string, names?: string[]) {\n  return `\n    SELECT \n      q.name,\n      q.policy,\n      q.retry_limit as \"retryLimit\",\n      q.retry_delay as \"retryDelay\",\n      q.retry_backoff as \"retryBackoff\",\n      q.retry_delay_max as \"retryDelayMax\",\n      q.expire_seconds as \"expireInSeconds\",\n      q.retention_seconds as \"retentionSeconds\",\n      q.deletion_seconds as \"deleteAfterSeconds\",\n      q.partition,\n      q.dead_letter as \"deadLetter\",\n      q.deferred_count as \"deferredCount\",\n      q.warning_queued as \"warningQueueSize\",\n      q.queued_count as \"queuedCount\",\n      q.active_count as \"activeCount\",\n      q.total_count as \"totalCount\",\n      q.singletons_active as \"singletonsActive\",\n      q.table_name as \"table\",\n      q.created_on as \"createdOn\",\n      q.updated_on as \"updatedOn\"\n    FROM ${schema}.queue q\n    ${names ? `WHERE q.name IN (${names.map(i => `'${i}'`)})` : ''}\n   `\n}\n\nfunction deleteJobsById (schema: string, table: string) {\n  return `\n    WITH results as (\n      DELETE FROM ${schema}.${table}\n      WHERE name = $1\n        AND id IN (SELECT UNNEST($2::uuid[]))        \n      RETURNING 1\n    )\n    SELECT COUNT(*) from results\n  `\n}\n\nfunction deleteQueuedJobs (schema: string, table: string) {\n  return `DELETE from ${schema}.${table} WHERE name = $1 and state < '${JOB_STATES.active}'`\n}\n\nfunction deleteStoredJobs (schema: string, table: string) {\n  return `DELETE from ${schema}.${table} WHERE name = $1 and state > '${JOB_STATES.active}'`\n}\n\nfunction truncateTable (schema: string, table: string) {\n  return `TRUNCATE ${schema}.${table}`\n}\n\nfunction deleteAllJobs (schema: string, table: string) {\n  return `DELETE from ${schema}.${table} WHERE name = $1`\n}\n\nfunction getSchedules (schema: string) {\n  return `SELECT * FROM ${schema}.schedule`\n}\n\nfunction getSchedulesByQueue (schema: string) {\n  return `SELECT * FROM ${schema}.schedule WHERE name = $1 AND COALESCE(key, '') = $2`\n}\n\nfunction schedule (schema: string) {\n  return `\n    INSERT INTO ${schema}.schedule (name, key, cron, timezone, data, options)\n    VALUES ($1, $2, $3, $4, $5, $6)\n    ON CONFLICT (name, key) DO UPDATE SET\n      cron = EXCLUDED.cron,\n      timezone = EXCLUDED.timezone,\n      data = EXCLUDED.data,\n      options = EXCLUDED.options,\n      updated_on = now()\n  `\n}\n\nfunction unschedule (schema: string) {\n  return `\n    DELETE FROM ${schema}.schedule\n    WHERE name = $1\n      AND COALESCE(key, '') = $2\n  `\n}\n\nfunction subscribe (schema: string) {\n  return `\n    INSERT INTO ${schema}.subscription (event, name)\n    VALUES ($1, $2)\n    ON CONFLICT (event, name) DO UPDATE SET\n      event = EXCLUDED.event,\n      name = EXCLUDED.name,\n      updated_on = now()\n  `\n}\n\nfunction unsubscribe (schema: string) {\n  return `\n    DELETE FROM ${schema}.subscription\n    WHERE event = $1 and name = $2\n  `\n}\n\nfunction getQueuesForEvent (schema: string) {\n  return `\n    SELECT name FROM ${schema}.subscription\n    WHERE event = $1\n  `\n}\n\nfunction getTime () {\n  return \"SELECT round(date_part('epoch', now()) * 1000) as time\"\n}\n\nfunction getVersion (schema: string) {\n  return `SELECT version from ${schema}.version`\n}\n\nfunction setVersion (schema: string, version: number) {\n  return `UPDATE ${schema}.version SET version = '${version}'`\n}\n\nfunction versionTableExists (schema: string) {\n  return `SELECT to_regclass('${schema}.version') as name`\n}\n\nfunction insertVersion (schema: string, version: number) {\n  return `INSERT INTO ${schema}.version(version) VALUES ('${version}')`\n}\n\ninterface FetchJobOptions {\n  schema: string\n  table: string\n  name: string\n  policy: string | undefined\n  limit: number\n  includeMetadata?: boolean\n  priority?: boolean\n  ignoreStartAfter?: boolean\n  ignoreSingletons: string[] | null\n}\n\nfunction fetchNextJob ({ schema, table, name, policy, limit, includeMetadata, priority = true, ignoreStartAfter = false, ignoreSingletons = null }: FetchJobOptions) {\n  const singletonFetch = limit > 1 && (policy === QUEUE_POLICIES.singleton || policy === QUEUE_POLICIES.stately)\n  const cte = singletonFetch ? 'grouped' : 'next'\n\n  return `\n    WITH next as (\n      SELECT id ${singletonFetch ? ', singleton_key' : ''}\n      FROM ${schema}.${table}\n      WHERE name = '${name}'\n        AND state < '${JOB_STATES.active}'\n        ${ignoreStartAfter ? '' : 'AND start_after < now()'}\n        ${ignoreSingletons != null && ignoreSingletons?.length > 0 ? `AND singleton_key NOT IN (${ignoreSingletons.map(i => `'${i}'`).join()})` : ''}\n      ORDER BY ${priority ? 'priority desc, ' : ''}created_on, id\n      LIMIT ${limit}\n      FOR UPDATE SKIP LOCKED\n    )\n    ${singletonFetch ? ', grouped as ( SELECT id, row_number() OVER (PARTITION BY singleton_key) FROM next)' : ''}\n    UPDATE ${schema}.${table} j SET\n      state = '${JOB_STATES.active}',\n      started_on = now(),\n      retry_count = CASE WHEN started_on IS NOT NULL THEN retry_count + 1 ELSE retry_count END\n    FROM ${cte}\n    WHERE name = '${name}' AND j.id = ${cte}.id\n      ${singletonFetch ? ` AND ${cte}.row_number = 1` : ''}\n    RETURNING j.${includeMetadata ? JOB_COLUMNS_ALL : JOB_COLUMNS_MIN}      \n  `\n}\n\nfunction completeJobs (schema: string, table: string) {\n  return `\n    WITH results AS (\n      UPDATE ${schema}.${table}\n      SET completed_on = now(),\n        state = '${JOB_STATES.completed}',\n        output = $3::jsonb\n      WHERE name = $1\n        AND id IN (SELECT UNNEST($2::uuid[]))\n        AND state = '${JOB_STATES.active}'\n      RETURNING *\n    )\n    SELECT COUNT(*) FROM results\n  `\n}\n\nfunction cancelJobs (schema: string, table: string) {\n  return `\n    WITH results as (\n      UPDATE ${schema}.${table}\n      SET completed_on = now(),\n        state = '${JOB_STATES.cancelled}'\n      WHERE name = $1\n        AND id IN (SELECT UNNEST($2::uuid[]))\n        AND state < '${JOB_STATES.completed}'\n      RETURNING 1\n    )\n    SELECT COUNT(*) from results\n  `\n}\n\nfunction resumeJobs (schema: string, table: string) {\n  return `\n    WITH results as (\n      UPDATE ${schema}.${table}\n      SET completed_on = NULL,\n        state = '${JOB_STATES.created}'\n      WHERE name = $1\n        AND id IN (SELECT UNNEST($2::uuid[]))\n        AND state = '${JOB_STATES.cancelled}'\n      RETURNING 1\n    )\n    SELECT COUNT(*) from results\n  `\n}\n\ninterface InsertJobsOptions {\n  table: string\n  name: string\n  returnId?: boolean\n}\n\nfunction insertJobs (schema: string, { table, name, returnId = true }: InsertJobsOptions) {\n  const sql = `\n    INSERT INTO ${schema}.${table} (\n      id,\n      name,\n      data,\n      priority,\n      start_after,\n      singleton_key,\n      singleton_on,\n      expire_seconds,\n      deletion_seconds,\n      keep_until,\n      retry_limit,\n      retry_delay,\n      retry_backoff,\n      retry_delay_max,\n      policy,\n      dead_letter\n    )\n    SELECT\n      COALESCE(id, gen_random_uuid()) as id,\n      '${name}' as name,\n      data,\n      COALESCE(priority, 0) as priority,\n      j.start_after,\n      \"singletonKey\",\n      CASE\n        WHEN \"singletonSeconds\" IS NOT NULL THEN 'epoch'::timestamp + '1s'::interval * (\"singletonSeconds\" * floor(( date_part('epoch', now()) + COALESCE(\"singletonOffset\",0)) / \"singletonSeconds\" ))\n        ELSE NULL\n        END as singleton_on,\n      COALESCE(\"expireInSeconds\", q.expire_seconds) as expire_seconds,\n      COALESCE(\"deleteAfterSeconds\", q.deletion_seconds) as deletion_seconds,\n      j.start_after + (COALESCE(\"retentionSeconds\", q.retention_seconds) * interval '1s') as keep_until,\n      COALESCE(\"retryLimit\", q.retry_limit) as retry_limit,\n      COALESCE(\"retryDelay\", q.retry_delay) as retry_delay,\n      COALESCE(\"retryBackoff\", q.retry_backoff, false) as retry_backoff,\n      COALESCE(\"retryDelayMax\", q.retry_delay_max) as retry_delay_max,\n      q.policy,\n      q.dead_letter\n    FROM (\n      SELECT *,\n        CASE\n          WHEN right(\"startAfter\", 1) = 'Z' THEN CAST(\"startAfter\" as timestamp with time zone)\n          ELSE now() + CAST(COALESCE(\"startAfter\",'0') as interval)\n          END as start_after\n      FROM json_to_recordset($1::json) as x (\n        id uuid,\n        priority integer,\n        data jsonb,\n        \"startAfter\" text,\n        \"retryLimit\" integer,\n        \"retryDelay\" integer,\n        \"retryDelayMax\" integer,\n        \"retryBackoff\" boolean,\n        \"singletonKey\" text,\n        \"singletonSeconds\" integer,\n        \"singletonOffset\" integer,\n        \"expireInSeconds\" integer,\n        \"deleteAfterSeconds\" integer,\n        \"retentionSeconds\" integer\n      ) \n    ) j\n    JOIN ${schema}.queue q ON q.name = '${name}'\n    ON CONFLICT DO NOTHING\n    ${returnId ? 'RETURNING id' : ''}\n  `\n\n  return sql\n}\n\nfunction failJobsById (schema: string, table: string) {\n  const where = `name = $1 AND id IN (SELECT UNNEST($2::uuid[])) AND state < '${JOB_STATES.completed}'`\n  const output = '$3::jsonb'\n\n  return failJobs(schema, table, where, output)\n}\n\nfunction failJobsByTimeout (schema: string, table: string, queues: string[]) {\n  const where = `state = '${JOB_STATES.active}'\n            AND (started_on + expire_seconds * interval '1s') < now()\n            AND name IN (${getQueueInClause(queues)})`\n\n  const output = '\\'{ \"value\": { \"message\": \"job timed out\" } }\\'::jsonb'\n\n  return locked(schema, failJobs(schema, table, where, output), table + 'failJobsByTimeout')\n}\n\nfunction failJobs (schema: string, table: string, where: string, output: string) {\n  return `\n    WITH deleted_jobs AS (\n      DELETE FROM ${schema}.${table}\n      WHERE ${where}\n      RETURNING *\n    ),\n    retried_jobs AS (\n      INSERT INTO ${schema}.${table} (\n        id,\n        name,\n        priority,\n        data,\n        state,\n        retry_limit,\n        retry_count,\n        retry_delay,\n        retry_backoff,\n        retry_delay_max,\n        start_after,\n        started_on,\n        singleton_key,\n        singleton_on,\n        expire_seconds,\n        deletion_seconds,\n        created_on,\n        completed_on,\n        keep_until,\n        policy,\n        output,\n        dead_letter\n      )\n      SELECT\n        id,\n        name,\n        priority,\n        data,\n        CASE\n          WHEN retry_count < retry_limit THEN '${JOB_STATES.retry}'::${schema}.job_state\n          ELSE '${JOB_STATES.failed}'::${schema}.job_state\n          END as state,\n        retry_limit,\n        retry_count,\n        retry_delay,\n        retry_backoff,\n        retry_delay_max,\n        CASE WHEN retry_count = retry_limit THEN start_after\n             WHEN NOT retry_backoff THEN now() + retry_delay * interval '1'\n             ELSE now() + LEAST(\n               retry_delay_max,\n               retry_delay + (\n                2 ^ LEAST(16, retry_count + 1) / 2 +\n                2 ^ LEAST(16, retry_count + 1) / 2 * random()\n               )\n             ) * interval '1s'\n        END as start_after,\n        started_on,\n        singleton_key,\n        singleton_on,\n        expire_seconds,\n        deletion_seconds,\n        created_on,\n        CASE WHEN retry_count < retry_limit THEN NULL ELSE now() END as completed_on,\n        keep_until,\n        policy,\n        ${output},\n        dead_letter\n      FROM deleted_jobs\n      ON CONFLICT DO NOTHING\n      RETURNING *\n    ),\n    failed_jobs as (\n      INSERT INTO ${schema}.${table} (\n        id,\n        name,\n        priority,\n        data,\n        state,\n        retry_limit,\n        retry_count,\n        retry_delay,\n        retry_backoff,\n        retry_delay_max,\n        start_after,\n        started_on,\n        singleton_key,\n        singleton_on,\n        expire_seconds,\n        deletion_seconds,\n        created_on,\n        completed_on,\n        keep_until,\n        policy,\n        output,\n        dead_letter\n      )\n      SELECT\n        id,\n        name,\n        priority,\n        data,\n        '${JOB_STATES.failed}'::${schema}.job_state as state,\n        retry_limit,\n        retry_count,\n        retry_delay,\n        retry_backoff,\n        retry_delay_max,\n        start_after,\n        started_on,\n        singleton_key,\n        singleton_on,\n        expire_seconds,\n        deletion_seconds,\n        created_on,\n        now() as completed_on,\n        keep_until,\n        policy,\n        ${output},\n        dead_letter\n      FROM deleted_jobs\n      WHERE id NOT IN (SELECT id from retried_jobs)\n      RETURNING *\n    ),\n    results as (\n      SELECT * FROM retried_jobs\n      UNION ALL\n      SELECT * FROM failed_jobs\n    ),\n    dlq_jobs as (\n      INSERT INTO ${schema}.job (name, data, output, retry_limit, retry_backoff, retry_delay, keep_until, deletion_seconds)\n      SELECT\n        r.dead_letter,\n        data,\n        output,\n        q.retry_limit,\n        q.retry_backoff,\n        q.retry_delay,\n        now() + q.retention_seconds * interval '1s',\n        q.deletion_seconds\n      FROM results r\n        JOIN ${schema}.queue q ON q.name = r.dead_letter\n      WHERE state = '${JOB_STATES.failed}'\n    )\n    SELECT COUNT(*) FROM results\n  `\n}\n\nfunction deletion (schema: string, table: string, queues: string[]) {\n  const sql = `\n    DELETE FROM ${schema}.${table}\n    WHERE name IN (${getQueueInClause(queues)})\n      AND\n      (\n        completed_on + deletion_seconds * interval '1s' < now()\n        OR\n        (state < '${JOB_STATES.active}' AND keep_until < now())\n      )        \n  `\n\n  return locked(schema, sql, table + 'deletion')\n}\n\nfunction retryJobs (schema: string, table: string) {\n  return `\n    WITH results as (\n      UPDATE ${schema}.job\n      SET state = '${JOB_STATES.retry}',\n        retry_limit = retry_limit + 1\n      WHERE name = $1\n        AND id IN (SELECT UNNEST($2::uuid[]))\n        AND state = '${JOB_STATES.failed}'\n      RETURNING 1\n    )\n    SELECT COUNT(*) from results\n  `\n}\n\nfunction getQueueStats (schema: string, table: string, queues: string[]) {\n  return `\n    SELECT\n        name, \n        (count(*) FILTER (WHERE start_after > now()))::int as \"deferredCount\",\n        (count(*) FILTER (WHERE state < '${JOB_STATES.active}'))::int as \"queuedCount\",\n        (count(*) FILTER (WHERE state = '${JOB_STATES.active}'))::int as \"activeCount\",\n        count(*)::int as \"totalCount\",\n        array_agg(singleton_key) FILTER (WHERE policy IN ('${QUEUE_POLICIES.singleton}','${QUEUE_POLICIES.stately}') AND state = '${JOB_STATES.active}') as \"singletonsActive\"\n      FROM ${schema}.${table}\n      WHERE name IN (${getQueueInClause(queues)})\n      GROUP BY 1\n  `\n}\n\nfunction cacheQueueStats (schema: string, table: string, queues: string[]) {\n  const sql = `\n    WITH stats AS (${getQueueStats(schema, table, queues)})\n    UPDATE ${schema}.queue SET\n      deferred_count = \"deferredCount\",\n      queued_count = \"queuedCount\",\n      active_count = \"activeCount\",\n      total_count = \"totalCount\",\n      singletons_active = \"singletonsActive\"\n    FROM stats\n      WHERE queue.name = stats.name\n    RETURNING\n      queue.name,\n      \"queuedCount\",\n      warning_queued as \"warningQueueSize\"\n  `\n\n  return locked(schema, sql, 'queue-stats')\n}\n\nfunction locked (schema: string, query: string | string[], key?: string) {\n  if (Array.isArray(query)) {\n    query = query.join(';\\n')\n  }\n\n  return `\n    BEGIN;\n    SET LOCAL lock_timeout = 30000;\n    SET LOCAL idle_in_transaction_session_timeout = 30000;\n    ${advisoryLock(schema, key)};\n    ${query};\n    COMMIT;\n  `\n}\n\nfunction advisoryLock (schema: string, key?: string) {\n  return `SELECT pg_advisory_xact_lock(\n      ('x' || encode(sha224((current_database() || '.pgboss.${schema}${key || ''}')::bytea), 'hex'))::bit(64)::bigint\n  )`\n}\n\nfunction assertMigration (schema: string, version: number) {\n  // raises 'division by zero' if already on desired schema version\n  return `SELECT version::int/(version::int-${version}) from ${schema}.version`\n}\n\nfunction getJobById (schema: string, table: string) {\n  return `SELECT ${JOB_COLUMNS_ALL} FROM ${schema}.${table} WHERE name = $1 AND id = $2`\n}\n\nfunction getQueueInClause (queues: string[]) {\n  return queues.map(i => `'${i}'`).join(',')\n}\n\nexport {\n  create,\n  insertVersion,\n  getVersion,\n  setVersion,\n  versionTableExists,\n  fetchNextJob,\n  completeJobs,\n  cancelJobs,\n  resumeJobs,\n  retryJobs,\n  deleteJobsById,\n  deleteAllJobs,\n  deleteQueuedJobs,\n  deleteStoredJobs,\n  truncateTable,\n  failJobsById,\n  failJobsByTimeout,\n  insertJobs,\n  getTime,\n  getSchedules,\n  getSchedulesByQueue,\n  schedule,\n  unschedule,\n  subscribe,\n  unsubscribe,\n  getQueuesForEvent,\n  deletion,\n  cacheQueueStats,\n  updateQueue,\n  createQueue,\n  deleteQueue,\n  getQueues,\n  getQueueStats,\n  trySetQueueMonitorTime,\n  trySetQueueDeletionTime,\n  trySetCronTime,\n  locked,\n  assertMigration,\n  getJobById,\n  QUEUE_POLICIES,\n  JOB_STATES,\n  MIGRATE_RACE_MESSAGE,\n  CREATE_RACE_MESSAGE,\n  DEFAULT_SCHEMA,\n}\n","import assert from 'node:assert'\nimport { DEFAULT_SCHEMA } from './plans.ts'\nimport type * as types from './types.ts'\n\nconst POLICY = {\n  MAX_EXPIRATION_HOURS: 24,\n  MIN_POLLING_INTERVAL_MS: 500,\n  MAX_RETENTION_DAYS: 365\n}\n\nfunction assertObjectName (value: string, name: string = 'Name') {\n  assert(/^[\\w.-]+$/.test(value), `${name} can only contain alphanumeric characters, underscores, hyphens, or periods`)\n}\n\nfunction validateQueueArgs (config: any = {}) {\n  assert(!('deadLetter' in config) || config.deadLetter === null || (typeof config.deadLetter === 'string'), 'deadLetter must be a string')\n\n  if (config.deadLetter) {\n    assertObjectName(config.deadLetter, 'deadLetter')\n  }\n\n  validateRetryConfig(config)\n  validateExpirationConfig(config)\n  validateRetentionConfig(config)\n  validateDeletionConfig(config)\n}\n\nfunction checkSendArgs (args: any): types.Request {\n  let name, data, options\n\n  if (typeof args[0] === 'string') {\n    name = args[0]\n    data = args[1]\n\n    assert(typeof data !== 'function', 'send() cannot accept a function as the payload.  Did you intend to use work()?')\n\n    options = args[2]\n  } else if (typeof args[0] === 'object') {\n    assert(args.length === 1, 'send object API only accepts 1 argument')\n\n    const job = args[0]\n\n    assert(job, 'boss requires all jobs to have a name')\n\n    name = job.name\n    data = job.data\n    options = job.options\n  }\n\n  options = options || {}\n\n  assert(name, 'boss requires all jobs to have a queue name')\n  assert(typeof options === 'object', 'options should be an object')\n\n  options = { ...options }\n\n  assert(!('priority' in options) || (Number.isInteger(options.priority)), 'priority must be an integer')\n  options.priority = options.priority || 0\n\n  options.startAfter = (options.startAfter instanceof Date && typeof options.startAfter.toISOString === 'function')\n    ? options.startAfter.toISOString()\n    : (+options.startAfter > 0)\n        ? '' + options.startAfter\n        : (typeof options.startAfter === 'string')\n            ? options.startAfter\n            : undefined\n\n  validateRetryConfig(options)\n  validateExpirationConfig(options)\n  validateRetentionConfig(options)\n  validateDeletionConfig(options)\n\n  return { name, data, options }\n}\n\nfunction checkWorkArgs (name: string, args: any[]): {\n  options: types.ResolvedWorkOptions\n  callback: types.WorkHandler<any>\n} {\n  let options, callback\n\n  assert(name, 'missing job name')\n\n  if (args.length === 1) {\n    callback = args[0]\n    options = {}\n  } else if (args.length > 1) {\n    options = args[0] || {}\n    callback = args[1]\n  }\n\n  assert(typeof callback === 'function', 'expected callback to be a function')\n  assert(typeof options === 'object', 'expected config to be an object')\n\n  options = { ...options }\n\n  applyPollingInterval(options)\n\n  assert(!('batchSize' in options) || (Number.isInteger(options.batchSize) && options.batchSize >= 1), 'batchSize must be an integer > 0')\n  assert(!('includeMetadata' in options) || typeof options.includeMetadata === 'boolean', 'includeMetadata must be a boolean')\n  assert(!('priority' in options) || typeof options.priority === 'boolean', 'priority must be a boolean')\n\n  options.batchSize = options.batchSize || 1\n\n  return { options, callback }\n}\n\nfunction checkFetchArgs (name: string, options: any) {\n  assert(name, 'missing queue name')\n\n  assert(!('batchSize' in options) || (Number.isInteger(options.batchSize) && options.batchSize >= 1), 'batchSize must be an integer > 0')\n  assert(!('includeMetadata' in options) || typeof options.includeMetadata === 'boolean', 'includeMetadata must be a boolean')\n  assert(!('priority' in options) || typeof options.priority === 'boolean', 'priority must be a boolean')\n  assert(!('ignoreStartAfter' in options) || typeof options.ignoreStartAfter === 'boolean', 'ignoreStartAfter must be a boolean')\n\n  options.batchSize = options.batchSize || 1\n}\n\nfunction getConfig (value: string | types.ConstructorOptions): types.ResolvedConstructorOptions {\n  assert(value && (typeof value === 'object' || typeof value === 'string'),\n    'configuration assert: string or config object is required to connect to postgres')\n\n  const config = (typeof value === 'string')\n    ? { connectionString: value }\n    : { ...value }\n\n  config.schedule = ('schedule' in config) ? config.schedule : true\n  config.supervise = ('supervise' in config) ? config.supervise : true\n  config.migrate = ('migrate' in config) ? config.migrate : true\n  config.createSchema = ('createSchema' in config) ? config.createSchema : true\n\n  applySchemaConfig(config)\n  applyOpsConfig(config)\n  applyScheduleConfig(config)\n  validateWarningConfig(config)\n\n  return config as types.ResolvedConstructorOptions\n}\n\nfunction applySchemaConfig (config: types.ConstructorOptions) {\n  if (config.schema) {\n    assertPostgresObjectName(config.schema)\n  }\n\n  config.schema = config.schema || DEFAULT_SCHEMA\n}\n\nfunction validateWarningConfig (config: any) {\n  assert(!('warningQueueSize' in config) || config.warningQueueSize >= 1,\n    'configuration assert: warningQueueSize must be at least 1')\n\n  assert(!('warningSlowQuerySeconds' in config) || config.warningSlowQuerySeconds >= 1,\n    'configuration assert: warningSlowQuerySeconds must be at least 1')\n}\n\nfunction assertPostgresObjectName (name: string) {\n  assert(typeof name === 'string', 'Name must be a string')\n  assert(name.length <= 50, 'Name cannot exceed 50 characters')\n  assert(!/\\W/.test(name), 'Name can only contain alphanumeric characters or underscores')\n  assert(!/^\\d/.test(name), 'Name cannot start with a number')\n}\n\nfunction assertQueueName (name: string) {\n  assert(name, 'Name is required')\n  assert(typeof name === 'string', 'Name must be a string')\n  assertObjectName(name)\n}\n\nfunction assertKey (key: string) {\n  if (!key) return\n  assert(typeof key === 'string', 'Key must be a string')\n  assertObjectName(key, 'Key')\n}\n\nfunction validateRetentionConfig (config: any) {\n  assert(!('retentionSeconds' in config) || config.retentionSeconds >= 1,\n    'configuration assert: retentionSeconds must be at least every second')\n}\n\nfunction validateExpirationConfig (config: any) {\n  assert(!('expireInSeconds' in config) || config.expireInSeconds >= 1,\n    'configuration assert: expireInSeconds must be at least every second')\n\n  assert(!config.expireInSeconds || config.expireInSeconds / 60 / 60 < POLICY.MAX_EXPIRATION_HOURS, `configuration assert: expiration cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`)\n}\n\nfunction validateRetryConfig (config: any) {\n  assert(!('retryDelay' in config) || (Number.isInteger(config.retryDelay) && config.retryDelay >= 0), 'retryDelay must be an integer >= 0')\n  assert(!('retryLimit' in config) || (Number.isInteger(config.retryLimit) && config.retryLimit >= 0), 'retryLimit must be an integer >= 0')\n  assert(!('retryBackoff' in config) || (config.retryBackoff === true || config.retryBackoff === false), 'retryBackoff must be either true or false')\n  assert(!('retryDelayMax' in config) || config.retryDelayMax === null || config.retryBackoff === true, 'retryDelayMax can only be set if retryBackoff is true')\n  assert(!('retryDelayMax' in config) || config.retryDelayMax === null || (Number.isInteger(config.retryDelayMax) && config.retryDelayMax >= 0), 'retryDelayMax must be an integer >= 0')\n}\n\nfunction applyPollingInterval (config: any) {\n  assert(!('pollingIntervalSeconds' in config) || config.pollingIntervalSeconds >= POLICY.MIN_POLLING_INTERVAL_MS / 1000,\n    `configuration assert: pollingIntervalSeconds must be at least every ${POLICY.MIN_POLLING_INTERVAL_MS}ms`)\n\n  config.pollingInterval = ('pollingIntervalSeconds' in config)\n    ? config.pollingIntervalSeconds * 1000\n    : 2000\n}\n\nfunction applyOpsConfig (config: any) {\n  assert(!('superviseIntervalSeconds' in config) || config.superviseIntervalSeconds >= 1,\n    'configuration assert: superviseIntervalSeconds must be at least every second')\n\n  config.superviseIntervalSeconds = config.superviseIntervalSeconds || 60\n\n  assert(config.superviseIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS,\n    `configuration assert: superviseIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`)\n\n  assert(!('maintenanceIntervalSeconds' in config) || config.maintenanceIntervalSeconds >= 1,\n    'configuration assert: maintenanceIntervalSeconds must be at least every second')\n\n  config.maintenanceIntervalSeconds = config.maintenanceIntervalSeconds || POLICY.MAX_EXPIRATION_HOURS * 60 * 60\n\n  assert(config.maintenanceIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS,\n    `configuration assert: maintenanceIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`)\n\n  assert(!('monitorIntervalSeconds' in config) || config.monitorIntervalSeconds >= 1,\n    'configuration assert: monitorIntervalSeconds must be at least every second')\n\n  config.monitorIntervalSeconds = config.monitorIntervalSeconds || 60\n\n  assert(config.monitorIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS,\n    `configuration assert: monitorIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`)\n\n  assert(!('queueCacheIntervalSeconds' in config) || config.queueCacheIntervalSeconds >= 1,\n    'configuration assert: queueCacheIntervalSeconds must be at least every second')\n\n  config.queueCacheIntervalSeconds = config.queueCacheIntervalSeconds || 60\n\n  assert(config.queueCacheIntervalSeconds / 60 / 60 <= POLICY.MAX_EXPIRATION_HOURS,\n    `configuration assert: queueCacheIntervalSeconds cannot exceed ${POLICY.MAX_EXPIRATION_HOURS} hours`)\n}\n\nfunction validateDeletionConfig (config: any) {\n  assert(!('deleteAfterSeconds' in config) || config.deleteAfterSeconds >= 1,\n    'configuration assert: deleteAfterSeconds must be at least every second')\n}\n\nfunction applyScheduleConfig (config: any) {\n  assert(!('clockMonitorIntervalSeconds' in config) || (config.clockMonitorIntervalSeconds >= 1 && config.clockMonitorIntervalSeconds <= 600),\n    'configuration assert: clockMonitorIntervalSeconds must be between 1 second and 10 minutes')\n\n  config.clockMonitorIntervalSeconds = config.clockMonitorIntervalSeconds || 600\n\n  assert(!('cronMonitorIntervalSeconds' in config) || (config.cronMonitorIntervalSeconds >= 1 && config.cronMonitorIntervalSeconds <= 45),\n    'configuration assert: cronMonitorIntervalSeconds must be between 1 and 45 seconds')\n\n  config.cronMonitorIntervalSeconds = config.cronMonitorIntervalSeconds || 30\n\n  assert(!('cronWorkerIntervalSeconds' in config) || (config.cronWorkerIntervalSeconds >= 1 && config.cronWorkerIntervalSeconds <= 45),\n    'configuration assert: cronWorkerIntervalSeconds must be between 1 and 45 seconds')\n\n  config.cronWorkerIntervalSeconds = config.cronWorkerIntervalSeconds || 5\n}\n\nexport {\n  assertKey,\n  assertPostgresObjectName,\n  assertQueueName,\n  checkFetchArgs,\n  checkSendArgs,\n  checkWorkArgs,\n  getConfig,\n  POLICY,\n  validateQueueArgs\n}\n","import assert from 'node:assert'\nimport * as plans from './plans.ts'\nimport * as types from './types.ts'\n\nfunction flatten (schema: string, commands: string[], version: number) {\n  commands.unshift(plans.assertMigration(schema, version))\n  commands.push(plans.setVersion(schema, version))\n\n  return plans.locked(schema, commands)\n}\n\nfunction rollback (schema: string, version: number, migrations?: types.Migration[]) {\n  migrations = migrations || getAll(schema)\n\n  const result = migrations.find(i => i.version === version)\n\n  assert(result, `Version ${version} not found.`)\n\n  return flatten(schema, result.uninstall || [], result.previous)\n}\n\nfunction next (schema: string, version: number, migrations: types.Migration[] | undefined) {\n  migrations = migrations || getAll(schema)\n\n  const result = migrations.find(i => i.previous === version)\n\n  assert(result, `Version ${version} not found.`)\n\n  return flatten(schema, result.install, result.version)\n}\n\nfunction migrate (schema: string, version: number, migrations?: types.Migration[]) {\n  migrations = migrations || getAll(schema)\n\n  const result = migrations\n    .filter(i => i.previous >= version!)\n    .sort((a, b) => a.version - b.version)\n    .reduce((acc, i) => {\n      acc.install = acc.install.concat(i.install)\n      acc.version = i.version\n      return acc\n    }, { install: [] as string[], version })\n\n  assert(result.install.length > 0, `Version ${version} not found.`)\n\n  return flatten(schema, result.install, result.version!)\n}\n\nfunction getAll (schema: string): types.Migration[] {\n  return [\n    {\n      release: '11.1.0',\n      version: 26,\n      previous: 25,\n      install: [\n        `\n        CREATE OR REPLACE FUNCTION ${schema}.create_queue(queue_name text, options jsonb)\n        RETURNS VOID AS\n        $$\n        DECLARE\n          tablename varchar := CASE WHEN options->>'partition' = 'true'\n                                THEN 'j' || encode(sha224(queue_name::bytea), 'hex')\n                                ELSE 'job_common'\n                                END;\n          queue_created_on timestamptz;\n        BEGIN\n\n          WITH q as (\n            INSERT INTO ${schema}.queue (\n              name,\n              policy,\n              retry_limit,\n              retry_delay,\n              retry_backoff,\n              retry_delay_max,\n              expire_seconds,\n              retention_seconds,\n              deletion_seconds,\n              warning_queued,\n              dead_letter,\n              partition,\n              table_name\n            )\n            VALUES (\n              queue_name,\n              options->>'policy',\n              COALESCE((options->>'retryLimit')::int, 2),\n              COALESCE((options->>'retryDelay')::int, 0),\n              COALESCE((options->>'retryBackoff')::bool, false),\n              (options->>'retryDelayMax')::int,\n              COALESCE((options->>'expireInSeconds')::int, 900),\n              COALESCE((options->>'retentionSeconds')::int, 1209600),\n              COALESCE((options->>'deleteAfterSeconds')::int, 604800),\n              COALESCE((options->>'warningQueueSize')::int, 0),\n              options->>'deadLetter',\n              COALESCE((options->>'partition')::bool, false),\n              tablename\n            )\n            ON CONFLICT DO NOTHING\n            RETURNING created_on\n          )\n          SELECT created_on into queue_created_on from q;\n\n          IF queue_created_on IS NULL OR options->>'partition' IS DISTINCT FROM 'true' THEN\n            RETURN;\n          END IF;\n\n          EXECUTE format('CREATE TABLE ${schema}.%I (LIKE ${schema}.job INCLUDING DEFAULTS)', tablename);\n\n          EXECUTE format('ALTER TABLE ${schema}.%1$I ADD PRIMARY KEY (name, id)', tablename);\n          EXECUTE format('ALTER TABLE ${schema}.%1$I ADD CONSTRAINT q_fkey FOREIGN KEY (name) REFERENCES ${schema}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED', tablename);\n          EXECUTE format('ALTER TABLE ${schema}.%1$I ADD CONSTRAINT dlq_fkey FOREIGN KEY (dead_letter) REFERENCES ${schema}.queue (name) ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED', tablename);\n\n          EXECUTE format('CREATE INDEX %1$s_i5 ON ${schema}.%1$I (name, start_after) INCLUDE (priority, created_on, id) WHERE state < ''active''', tablename);\n          EXECUTE format('CREATE UNIQUE INDEX %1$s_i4 ON ${schema}.%1$I (name, singleton_on, COALESCE(singleton_key, '''')) WHERE state <> ''cancelled'' AND singleton_on IS NOT NULL', tablename);\n\n          IF options->>'policy' = 'short' THEN\n            EXECUTE format('CREATE UNIQUE INDEX %1$s_i1 ON ${schema}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state = ''created'' AND policy = ''short''', tablename);\n          ELSIF options->>'policy' = 'singleton' THEN\n            EXECUTE format('CREATE UNIQUE INDEX %1$s_i2 ON ${schema}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state = ''active'' AND policy = ''singleton''', tablename);\n          ELSIF options->>'policy' = 'stately' THEN\n            EXECUTE format('CREATE UNIQUE INDEX %1$s_i3 ON ${schema}.%1$I (name, state, COALESCE(singleton_key, '''')) WHERE state <= ''active'' AND policy = ''stately''', tablename);\n          ELSIF options->>'policy' = 'exclusive' THEN\n            EXECUTE format('CREATE UNIQUE INDEX %1$s_i6 ON ${schema}.%1$I (name, COALESCE(singleton_key, '''')) WHERE state <= ''active'' AND policy = ''exclusive''', tablename);\n          END IF;\n\n          EXECUTE format('ALTER TABLE ${schema}.%I ADD CONSTRAINT cjc CHECK (name=%L)', tablename, queue_name);\n          EXECUTE format('ALTER TABLE ${schema}.job ATTACH PARTITION ${schema}.%I FOR VALUES IN (%L)', tablename, queue_name);\n        END;\n        $$\n        LANGUAGE plpgsql;\n        `,\n        `CREATE UNIQUE INDEX job_i6 ON ${schema}.job_common (name, COALESCE(singleton_key, '')) WHERE state <= 'active' AND policy = 'exclusive'`\n      ],\n      uninstall: [\n        `DROP INDEX ${schema}.job_i6`\n      ]\n    },]\n}\n\nexport {\n  rollback,\n  next,\n  migrate,\n  getAll,\n}\n","{\n  \"name\": \"pg-boss\",\n  \"version\": \"12.1.1\",\n  \"description\": \"Queueing jobs in Postgres from Node.js like a boss\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.mjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.mts\",\n  \"engines\": {\n    \"node\": \">=22.12.0\"\n  },\n  \"exports\": {\n    \".\": \"./dist/index.mjs\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"dependencies\": {\n    \"cron-parser\": \"^5.4.0\",\n    \"pg\": \"^8.16.3\",\n    \"serialize-error\": \"^12.0.0\"\n  },\n  \"devDependencies\": {\n    \"@istanbuljs/nyc-config-typescript\": \"^1.0.2\",\n    \"@tsconfig/node22\": \"^22.0.2\",\n    \"@types/mocha\": \"^10.0.10\",\n    \"@types/node\": \"^22.19.0\",\n    \"@types/pg\": \"^8.15.6\",\n    \"eslint\": \"^9.39.1\",\n    \"luxon\": \"^3.7.2\",\n    \"mocha\": \"^11.7.5\",\n    \"neostandard\": \"^0.12.2\",\n    \"nyc\": \"^17.1.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"tsdown\": \"^0.16.0\",\n    \"tsx\": \"^4.20.6\",\n    \"typescript\": \"^5.9.3\"\n  },\n  \"scripts\": {\n    \"build\": \"tsdown\",\n    \"prepublishOnly\": \"npm test && npm run build\",\n    \"test\": \"eslint . && mocha test/**/*.ts\",\n    \"cover\": \"nyc npm test\",\n    \"tsc\": \"tsc --noEmit\",\n    \"readme\": \"node ./examples/readme.js\",\n    \"db:migrate\": \"node --import=tsx -e 'console.log(require(\\\"./src\\\").getMigrationPlans())'\",\n    \"db:construct\": \"node --import=tsx -e 'console.log(require(\\\"./src\\\").getConstructionPlans())'\"\n  },\n  \"pgboss\": {\n    \"schema\": 26\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/timgit/pg-boss.git\"\n  },\n  \"keywords\": [\n    \"postgresql\",\n    \"postgres\",\n    \"queue\",\n    \"job\"\n  ],\n  \"author\": \"timgit\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/timgit/pg-boss/issues\"\n  },\n  \"homepage\": \"https://timgit.github.io/pg-boss\",\n  \"files\": [\n    \"dist\",\n    \"README.md\",\n    \"LICENSE\",\n    \"package.json\"\n  ]\n}\n","import assert from 'node:assert'\nimport * as plans from './plans.ts'\nimport * as migrationStore from './migrationStore.ts'\nimport packageJson from '../package.json' with { type: 'json' }\nimport type * as types from './types.ts'\n\nconst schemaVersion = packageJson.pgboss.schema as number\n\nclass Contractor {\n  static constructionPlans (schema = plans.DEFAULT_SCHEMA, options = { createSchema: true }) {\n    return plans.create(schema, schemaVersion, options)\n  }\n\n  static migrationPlans (schema = plans.DEFAULT_SCHEMA, version = schemaVersion - 1) {\n    return migrationStore.migrate(schema, version)\n  }\n\n  static rollbackPlans (schema = plans.DEFAULT_SCHEMA, version = schemaVersion) {\n    return migrationStore.rollback(schema, version)\n  }\n\n  private config: types.ResolvedConstructorOptions\n  private db: types.IDatabase\n  private migrations: types.Migration[]\n\n  constructor (db: types.IDatabase, config: types.ResolvedConstructorOptions) {\n    this.config = config\n    this.db = db\n    this.migrations = this.config.migrations || migrationStore.getAll(this.config.schema)\n  }\n\n  async schemaVersion () {\n    const result = await this.db.executeSql(plans.getVersion(this.config.schema))\n    return result.rows.length ? parseInt(result.rows[0].version) : null\n  }\n\n  async isInstalled () {\n    const result = await this.db.executeSql(plans.versionTableExists(this.config.schema))\n    return !!result.rows[0].name\n  }\n\n  async start () {\n    const installed = await this.isInstalled()\n\n    if (installed) {\n      const version = await this.schemaVersion()\n\n      if (version !== null && schemaVersion > version) {\n        await this.migrate(version)\n      }\n    } else {\n      await this.create()\n    }\n  }\n\n  async check () {\n    const installed = await this.isInstalled()\n\n    if (!installed) {\n      throw new Error('pg-boss is not installed')\n    }\n\n    const version = await this.schemaVersion()\n\n    if (schemaVersion !== version) {\n      throw new Error('pg-boss database requires migrations')\n    }\n  }\n\n  async create () {\n    try {\n      const commands = plans.create(this.config.schema, schemaVersion, this.config)\n      await this.db.executeSql(commands)\n    } catch (err: any) {\n      assert(err.message.includes(plans.CREATE_RACE_MESSAGE), err)\n    }\n  }\n\n  async migrate (version: number) {\n    try {\n      const commands = migrationStore.migrate(this.config.schema, version, this.migrations)\n      await this.db.executeSql(commands)\n    } catch (err: any) {\n      assert(err.message.includes(plans.MIGRATE_RACE_MESSAGE), err)\n    }\n  }\n\n  async next (version: number) {\n    const commands = migrationStore.next(this.config.schema, version, this.migrations)\n    await this.db.executeSql(commands)\n  }\n\n  async rollback (version: number) {\n    const commands = migrationStore.rollback(this.config.schema, version, this.migrations)\n    await this.db.executeSql(commands)\n  }\n}\n\nexport default Contractor\n","import { CronExpressionParser } from 'cron-parser'\nimport EventEmitter from 'node:events'\n\nimport * as Attorney from './attorney.ts'\nimport type Manager from './manager.ts'\nimport * as plans from './plans.ts'\nimport * as types from './types.ts'\n\nexport const QUEUES = {\n  SEND_IT: '__pgboss__send-it'\n}\n\nconst EVENTS = {\n  error: 'error',\n  schedule: 'schedule',\n  warning: 'warning'\n}\n\nconst WARNINGS = {\n  CLOCK_SKEW: {\n    message: 'Warning: Clock skew between this instance and the database server. This will not break scheduling, but is emitted any time the skew exceeds 60 seconds.'\n  }\n}\n\nclass Timekeeper extends EventEmitter implements types.EventsMixin {\n  db: types.IDatabase\n  config: types.ResolvedConstructorOptions\n  manager: Manager\n\n  private stopped = true\n  private cronMonitorInterval: NodeJS.Timeout | null | undefined\n  private skewMonitorInterval: NodeJS.Timeout | null | undefined\n  private timekeeping: boolean | undefined\n\n  clockSkew = 0\n  events = EVENTS\n\n  constructor (db: types.IDatabase, manager: Manager, config: types.ResolvedConstructorOptions) {\n    super()\n\n    this.db = db\n    this.config = config\n    this.manager = manager\n  }\n\n  async start () {\n    this.stopped = false\n\n    await this.cacheClockSkew()\n    await this.manager.createQueue(QUEUES.SEND_IT)\n\n    const options = {\n      pollingIntervalSeconds: this.config.cronWorkerIntervalSeconds,\n      batchSize: 50\n    }\n\n    await this.manager.work<types.Request>(QUEUES.SEND_IT, options, (jobs) => this.onSendIt(jobs))\n\n    setImmediate(() => this.onCron())\n\n    this.cronMonitorInterval = setInterval(async () => await this.onCron(), this.config.cronMonitorIntervalSeconds! * 1000)\n    this.skewMonitorInterval = setInterval(async () => await this.cacheClockSkew(), this.config.clockMonitorIntervalSeconds! * 1000)\n  }\n\n  async stop () {\n    if (this.stopped) {\n      return\n    }\n\n    this.stopped = true\n\n    await this.manager.offWork(QUEUES.SEND_IT)\n\n    if (this.skewMonitorInterval) {\n      clearInterval(this.skewMonitorInterval)\n      this.skewMonitorInterval = null\n    }\n\n    if (this.cronMonitorInterval) {\n      clearInterval(this.cronMonitorInterval)\n      this.cronMonitorInterval = null\n    }\n  }\n\n  async cacheClockSkew () {\n    let skew = 0\n\n    try {\n      if (this.config.__test__force_clock_monitoring_error) {\n        throw new Error(this.config.__test__force_clock_monitoring_error)\n      }\n\n      const { rows } = await this.db.executeSql(plans.getTime())\n\n      const local = Date.now()\n\n      const dbTime = parseFloat(rows[0].time)\n\n      skew = dbTime - local\n\n      const skewSeconds = Math.abs(skew) / 1000\n\n      if (skewSeconds >= 60 || this.config.__test__force_clock_skew_warning) {\n        this.emit(this.events.warning, { message: WARNINGS.CLOCK_SKEW.message, data: { seconds: skewSeconds, direction: skew > 0 ? 'slower' : 'faster' } })\n      }\n    } catch (err) {\n      this.emit(this.events.error, err)\n    } finally {\n      this.clockSkew = skew\n    }\n  }\n\n  async onCron () {\n    try {\n      if (this.stopped || this.timekeeping) return\n\n      if (this.config.__test__force_cron_monitoring_error) {\n        throw new Error(this.config.__test__force_cron_monitoring_error)\n      }\n\n      this.timekeeping = true\n\n      const sql = plans.trySetCronTime(this.config.schema, this.config.cronMonitorIntervalSeconds)\n\n      if (!this.stopped) {\n        const { rows } = await this.db.executeSql(sql)\n\n        if (!this.stopped && rows.length === 1) {\n          await this.cron()\n        }\n      }\n    } catch (err) {\n      this.emit(this.events.error, err)\n    } finally {\n      this.timekeeping = false\n    }\n  }\n\n  async cron () {\n    const schedules = await this.getSchedules()\n\n    const scheduled = schedules\n      .filter(i => this.shouldSendIt(i.cron, i.timezone))\n      .map(({ name, key, data, options }): types.JobInsert => ({ data: { name, data, options }, singletonKey: `${name}__${key}`, singletonSeconds: 60 }))\n\n    if (scheduled.length > 0 && !this.stopped) {\n      await this.manager.insert(QUEUES.SEND_IT, scheduled)\n    }\n  }\n\n  shouldSendIt (cron: string, tz: string) {\n    const interval = CronExpressionParser.parse(cron, { tz, strict: false })\n\n    const prevTime = interval.prev()\n\n    const databaseTime = Date.now() + this.clockSkew\n\n    const prevDiff = (databaseTime - prevTime.getTime()) / 1000\n\n    return prevDiff < 60\n  }\n\n  private async onSendIt (jobs: types.Job<types.Request>[]): Promise<void> {\n    await Promise.allSettled(jobs.map(({ data }) => this.manager.send(data)))\n  }\n\n  async getSchedules (name?: string, key = '') : Promise<types.Schedule[]> {\n    let sql = plans.getSchedules(this.config.schema)\n    let params: unknown[] = []\n\n    if (name) {\n      sql = plans.getSchedulesByQueue(this.config.schema)\n      params = [name, key]\n    }\n\n    const { rows } = await this.db.executeSql(sql, params)\n\n    return rows\n  }\n\n  async schedule (name: string, cron: string, data?: unknown, options: types.ScheduleOptions = {}): Promise<void> {\n    const { tz = 'UTC', key = '', ...rest } = options\n\n    CronExpressionParser.parse(cron, { tz, strict: false })\n\n    Attorney.checkSendArgs([name, data, { ...rest }])\n    Attorney.assertKey(key)\n\n    try {\n      const sql = plans.schedule(this.config.schema)\n      await this.db.executeSql(sql, [name, key, cron, tz, data, options])\n    } catch (err: any) {\n      if (err.message.includes('foreign key')) {\n        err.message = `Queue ${name} not found`\n      }\n\n      throw err\n    }\n  }\n\n  async unschedule (name: string, key = ''): Promise<void> {\n    const sql = plans.unschedule(this.config.schema)\n    await this.db.executeSql(sql, [name, key])\n  }\n}\n\nexport default Timekeeper\n","import { setTimeout } from 'node:timers/promises'\n\n/**\n * When sql contains multiple queries, result is an array of objects with rows property\n * This function unwraps the result into a single object with rows property\n*/\nfunction unwrapSQLResult (result: { rows: any[] } | { rows: any[] }[]): { rows: any[] } {\n  if (Array.isArray(result)) {\n    return { rows: result.flatMap(i => i.rows) }\n  }\n\n  return result\n}\n\nexport interface AbortablePromise<T> extends Promise<T> {\n  abort: () => void\n}\n\nfunction delay (ms: number, error?: string): AbortablePromise<void> {\n  const ac = new AbortController()\n\n  const promise = new Promise<void>((resolve, reject) => {\n    setTimeout(ms, null, { signal: ac.signal })\n      .then(() => {\n        if (error) {\n          reject(new Error(error))\n        } else {\n          resolve()\n        }\n      })\n      .catch(resolve)\n  }) as AbortablePromise<void>\n\n  promise.abort = () => {\n    if (!ac.signal.aborted) {\n      ac.abort()\n    }\n  }\n\n  return promise\n}\n\nasync function resolveWithinSeconds<T> (promise: Promise<T>, seconds: number, message?: string): Promise<T | void> {\n  const timeout = Math.max(1, seconds) * 1000\n  const reject = delay(timeout, message)\n\n  let result\n\n  try {\n    result = await Promise.race([promise, reject])\n  } finally {\n    reject.abort()\n  }\n\n  return result\n}\n\nexport {\n  delay,\n  resolveWithinSeconds,\n  unwrapSQLResult\n}\n","import { type AbortablePromise, delay } from './tools.ts'\nimport type * as types from './types.ts'\n\nconst WORKER_STATES = {\n  created: 'created',\n  active: 'active',\n  stopping: 'stopping',\n  stopped: 'stopped'\n} as const\n\ninterface WorkerOptions<T> {\n  id: string\n  name: string\n  options: types.WorkOptions\n  interval: number\n  fetch: () => Promise<types.Job<T>[]>\n  onFetch: (jobs: types.Job<T>[]) => Promise<void>\n  onError: (err: any) => void\n}\n\nclass Worker<T = unknown> {\n  readonly id: string\n  readonly name: string\n  readonly options: types.WorkOptions\n  readonly fetch: () => Promise<types.Job<T>[]>\n  readonly onFetch: (jobs: types.Job<T>[]) => Promise<void>\n  readonly onError: (err: any) => void\n  readonly interval: number\n\n  jobs: types.Job<T>[] = []\n  createdOn = Date.now()\n  state: types.WorkerState = WORKER_STATES.created\n  lastFetchedOn: number | null = null\n  lastJobStartedOn: number | null = null\n  lastJobEndedOn: number | null = null\n  lastJobDuration: number | null = null\n  lastError: any = null\n  lastErrorOn: number | null = null\n  stopping = false\n  stopped = false\n  private loopDelayPromise: AbortablePromise<void> | null = null\n  private beenNotified = false\n\n  constructor ({ id, name, options, interval, fetch, onFetch, onError }: WorkerOptions<T>) {\n    this.id = id\n    this.name = name\n    this.options = options\n    this.fetch = fetch\n    this.onFetch = onFetch\n    this.onError = onError\n    this.interval = interval\n  }\n\n  notify () {\n    this.beenNotified = true\n\n    if (this.loopDelayPromise) {\n      this.loopDelayPromise.abort()\n    }\n  }\n\n  async start () {\n    this.state = WORKER_STATES.active\n\n    while (!this.stopping) {\n      const started = Date.now()\n\n      try {\n        this.beenNotified = false\n        const jobs = await this.fetch()\n\n        this.lastFetchedOn = Date.now()\n\n        if (jobs) {\n          this.jobs = jobs\n\n          this.lastJobStartedOn = this.lastFetchedOn\n\n          await this.onFetch(jobs)\n\n          this.lastJobEndedOn = Date.now()\n\n          this.jobs = []\n        }\n      } catch (err: any) {\n        this.lastErrorOn = Date.now()\n        this.lastError = err\n\n        err.message = `${err.message} (Queue: ${this.name}, Worker: ${this.id})`\n\n        this.onError(err)\n      }\n\n      const duration = Date.now() - started\n\n      this.lastJobDuration = duration\n\n      if (!this.stopping && !this.beenNotified && (this.interval - duration) > 100) {\n        this.loopDelayPromise = delay(this.interval - duration)\n        await this.loopDelayPromise\n        this.loopDelayPromise = null\n      }\n    }\n\n    this.stopping = false\n    this.stopped = true\n    this.state = WORKER_STATES.stopped\n  }\n\n  stop () {\n    this.stopping = true\n    this.state = WORKER_STATES.stopping\n\n    if (this.loopDelayPromise) {\n      this.loopDelayPromise.abort()\n    }\n  }\n\n  toWipData (): types.WipData {\n    return {\n      id: this.id,\n      name: this.name,\n      options: this.options,\n      state: this.state,\n      count: this.jobs.length,\n      createdOn: this.createdOn,\n      lastFetchedOn: this.lastFetchedOn,\n      lastJobStartedOn: this.lastJobStartedOn,\n      lastJobEndedOn: this.lastJobEndedOn,\n      lastError: this.lastError,\n      lastErrorOn: this.lastErrorOn,\n      lastJobDuration: this.lastJobDuration\n    }\n  }\n}\n\nexport default Worker\n","import assert, { notStrictEqual } from 'node:assert'\nimport { randomUUID } from 'node:crypto'\nimport EventEmitter from 'node:events'\nimport { serializeError as stringify } from 'serialize-error'\nimport * as Attorney from './attorney.ts'\nimport type Db from './db.ts'\nimport * as plans from './plans.ts'\nimport type Timekeeper from './timekeeper.ts'\nimport * as timekeeper from './timekeeper.ts'\nimport { delay, resolveWithinSeconds } from './tools.ts'\nimport * as types from './types.ts'\nimport Worker from './worker.ts'\n\nconst INTERNAL_QUEUES = Object.values(timekeeper.QUEUES).reduce<Record<string, string | undefined>>((acc, i) => ({ ...acc, [i]: i }), {})\n\nconst events = {\n  error: 'error',\n  wip: 'wip'\n}\n\nclass Manager extends EventEmitter implements types.EventsMixin {\n  events = events\n  db: (types.IDatabase & { _pgbdb?: false }) | Db\n  config: types.ResolvedConstructorOptions\n  wipTs: number\n  workers: Map<string, Worker>\n  stopped: boolean | undefined\n  queueCacheInterval: NodeJS.Timeout | undefined\n  timekeeper: Timekeeper | undefined\n  queues: Record<string, types.QueueResult> | null\n\n  constructor (db: types.IDatabase, config: types.ResolvedConstructorOptions) {\n    super()\n\n    this.config = config\n    this.db = db\n    this.wipTs = Date.now()\n    this.workers = new Map()\n    this.queues = null\n  }\n\n  async start () {\n    this.stopped = false\n    this.queueCacheInterval = setInterval(() => this.onCacheQueues({ emit: true }), this.config.queueCacheIntervalSeconds! * 1000)\n    await this.onCacheQueues()\n  }\n\n  async onCacheQueues ({ emit = false } = {}) {\n    try {\n      assert(!this.config.__test__throw_queueCache, 'test error')\n      const queues = await this.getQueues()\n      this.queues = queues.reduce<Record<string, types.QueueResult>>((acc, i) => { acc[i.name] = i; return acc }, {})\n    } catch (error: any) {\n      emit && this.emit(events.error, { ...error, message: error.message, stack: error.stack })\n    }\n  }\n\n  async getQueueCache (name: string): Promise<types.QueueResult> {\n    assert(this.queues, 'Queue cache is not initialized')\n\n    let queue = this.queues[name]\n\n    if (queue) {\n      return queue\n    }\n\n    queue = await this.getQueue(name)\n\n    if (!queue) {\n      throw new Error(`Queue ${name} does not exist`)\n    }\n\n    this.queues[name] = queue\n\n    return queue\n  }\n\n  async stop () {\n    this.stopped = true\n\n    clearInterval(this.queueCacheInterval)\n\n    for (const worker of this.workers.values()) {\n      if (!INTERNAL_QUEUES[worker.name]) {\n        await this.offWork(worker.name)\n      }\n    }\n  }\n\n  async failWip () {\n    for (const worker of this.workers.values()) {\n      const jobIds = worker.jobs.map(j => j.id)\n      if (jobIds.length) {\n        await this.fail(worker.name, jobIds, 'pg-boss shut down while active')\n      }\n    }\n  }\n\n  work<ReqData>(name: string, handler: types.WorkHandler<ReqData>): Promise<string>\n  work<ReqData>(name: string, options: types.WorkOptions & { includeMetadata: true }, handler: types.WorkWithMetadataHandler<ReqData>): Promise<string>\n  work<ReqData>(name: string, options: types.WorkOptions, handler: types.WorkHandler<ReqData>): Promise<string>\n  async work (name: string, ...args: unknown[]): Promise<string> {\n    const { options, callback } = Attorney.checkWorkArgs(name, args)\n    return await this.watch(name, options, callback)\n  }\n\n  private addWorker (worker: Worker<any>) {\n    this.workers.set(worker.id, worker)\n  }\n\n  private removeWorker (worker: Worker<any>) {\n    this.workers.delete(worker.id)\n  }\n\n  private getWorkers () {\n    return Array.from(this.workers.values())\n  }\n\n  private emitWip (name: string) {\n    if (!INTERNAL_QUEUES[name]) {\n      const now = Date.now()\n\n      if (now - this.wipTs > 2000) {\n        this.emit(events.wip, this.getWipData())\n        this.wipTs = now\n      }\n    }\n  }\n\n  getWipData (options: { includeInternal?: boolean } = {}) {\n    const { includeInternal = false } = options\n\n    const data = this.getWorkers()\n      .map(i => i.toWipData())\n      .filter(i => i.count > 0 && (!INTERNAL_QUEUES[i.name] || includeInternal))\n\n    return data\n  }\n\n  private async watch<T> (name: string, options: types.ResolvedWorkOptions, callback: types.WorkHandler<T>): Promise<string> {\n    if (this.stopped) {\n      throw new Error('Workers are disabled. pg-boss is stopped')\n    }\n\n    const {\n      pollingInterval: interval,\n      batchSize,\n      includeMetadata = false,\n      priority = true\n    } = options\n\n    const id = randomUUID({ disableEntropyCache: true })\n\n    const fetch = () => this.fetch<T>(name, { batchSize, includeMetadata, priority })\n\n    const onFetch = async (jobs: types.Job<T>[]) => {\n      if (!jobs.length) {\n        return\n      }\n\n      if (this.config.__test__throw_worker) {\n        throw new Error('__test__throw_worker')\n      }\n\n      this.emitWip(name)\n\n      const maxExpiration = jobs.reduce((acc, i) => Math.max(acc, i.expireInSeconds), 0)\n      const jobIds = jobs.map(job => job.id)\n\n      try {\n        const result = await resolveWithinSeconds(callback(jobs), maxExpiration, `handler execution exceeded ${maxExpiration}s`)\n        await this.complete(name, jobIds, jobIds.length === 1 ? result : undefined)\n      } catch (err: any) {\n        await this.fail(name, jobIds, err)\n      }\n\n      this.emitWip(name)\n    }\n\n    const onError = (error: any) => {\n      this.emit(events.error, { ...error, message: error.message, stack: error.stack, queue: name, worker: id })\n    }\n\n    const worker = new Worker<T>({ id, name, options, interval, fetch, onFetch, onError })\n\n    this.addWorker(worker)\n\n    worker.start()\n\n    return id\n  }\n\n  async offWork (value: string | types.OffWorkOptions): Promise<void> {\n    assert(value, 'Missing required argument')\n\n    const query = (typeof value === 'string')\n      ? { filter: (i: Worker<any>) => i.name === value }\n      : (typeof value === 'object' && value.id)\n          ? { filter: (i: Worker<any>) => i.id === value.id }\n          : null\n\n    assert(query, 'Invalid argument. Expected string or object: { id }')\n\n    const workers = this.getWorkers().filter(i => query.filter(i) && !i.stopping && !i.stopped)\n\n    if (workers.length === 0) {\n      return\n    }\n\n    for (const worker of workers) {\n      worker.stop()\n    }\n\n    setImmediate(async () => {\n      while (!workers.every(w => w.stopped)) {\n        await delay(1000)\n      }\n\n      for (const worker of workers) {\n        this.removeWorker(worker)\n      }\n    })\n  }\n\n  notifyWorker (workerId: string): void {\n    this.workers.get(workerId)?.notify()\n  }\n\n  async subscribe (event: string, name: string): Promise<void> {\n    assert(event, 'Missing required argument')\n    assert(name, 'Missing required argument')\n    const sql = plans.subscribe(this.config.schema)\n    await this.db.executeSql(sql, [event, name])\n  }\n\n  async unsubscribe (event: string, name: string): Promise<void> {\n    assert(event, 'Missing required argument')\n    assert(name, 'Missing required argument')\n    const sql = plans.unsubscribe(this.config.schema)\n    await this.db.executeSql(sql, [event, name])\n  }\n\n  publish (event: string, data?: object, options?: types.SendOptions): Promise<void>\n  async publish (event: string, data?: object, options?: types.SendOptions): Promise<void> {\n    assert(event, 'Missing required argument')\n    const sql = plans.getQueuesForEvent(this.config.schema)\n    const { rows } = await this.db.executeSql(sql, [event])\n\n    await Promise.allSettled(rows.map(({ name }) => this.send(name, data, options)))\n  }\n\n  send (request: types.Request): Promise<string | null>\n  send (name: string, data?: object | null, options?: types.SendOptions): Promise<string | null>\n  async send (...args: any[]): Promise<string | null> {\n    const result = Attorney.checkSendArgs(args)\n\n    return await this.createJob(result)\n  }\n\n  async sendAfter (name: string, data: object, options: types.SendOptions, after: Date | string | number): Promise<string | null> {\n    options = options ? { ...options } : {}\n    options.startAfter = after\n\n    const result = Attorney.checkSendArgs([name, data, options])\n\n    return await this.createJob(result)\n  }\n\n  async sendThrottled (name: string, data: object, options: types.SendOptions, seconds: number, key?: string): Promise<string | null> {\n    options = options ? { ...options } : {}\n    options.singletonSeconds = seconds\n    options.singletonNextSlot = false\n    options.singletonKey = key\n\n    const result = Attorney.checkSendArgs([name, data, options])\n\n    return await this.createJob(result)\n  }\n\n  async sendDebounced (name: string, data: object, options: types.SendOptions, seconds: number, key?: string): Promise<string | null> {\n    options = options ? { ...options } : {}\n    options.singletonSeconds = seconds\n    options.singletonNextSlot = true\n    options.singletonKey = key\n\n    const result = Attorney.checkSendArgs([name, data, options])\n\n    return await this.createJob(result)\n  }\n\n  async createJob (request: types.Request): Promise<string | null> {\n    const { name, data = null, options = {} } = request\n    const {\n      id = null,\n      db: wrapper,\n      priority,\n      startAfter,\n      singletonKey = null,\n      singletonSeconds,\n      singletonNextSlot,\n      expireInSeconds,\n      deleteAfterSeconds,\n      retentionSeconds,\n      keepUntil,\n      retryLimit,\n      retryDelay,\n      retryBackoff,\n      retryDelayMax\n    } = options\n\n    const job = {\n      id,\n      name,\n      data,\n      priority,\n      startAfter,\n      singletonKey,\n      singletonSeconds,\n      singletonOffset: 0 as number | undefined,\n      expireInSeconds,\n      deleteAfterSeconds,\n      retentionSeconds,\n      keepUntil,\n      retryLimit,\n      retryDelay,\n      retryBackoff,\n      retryDelayMax\n    }\n\n    const db = wrapper || this.db\n\n    const { table } = await this.getQueueCache(name)\n\n    const sql = plans.insertJobs(this.config.schema, { table, name, returnId: true })\n\n    const { rows: try1 } = await db.executeSql(sql, [JSON.stringify([job])])\n\n    if (try1.length === 1) {\n      return try1[0].id\n    }\n\n    if (singletonNextSlot) {\n      // delay starting by the offset to honor throttling config\n      job.startAfter = this.getDebounceStartAfter(singletonSeconds!, this.timekeeper!.clockSkew)\n      job.singletonOffset = singletonSeconds\n\n      const { rows: try2 } = await db.executeSql(sql, [JSON.stringify([job])])\n\n      if (try2.length === 1) {\n        return try2[0].id\n      }\n    }\n\n    return null\n  }\n\n  async insert (name: string, jobs: types.JobInsert[], options: types.InsertOptions = {}) {\n    assert(Array.isArray(jobs), 'jobs argument should be an array')\n\n    const { table } = await this.getQueueCache(name)\n\n    const db = this.assertDb(options)\n\n    const sql = plans.insertJobs(this.config.schema, { table, name, returnId: false })\n\n    const { rows } = await db.executeSql(sql, [JSON.stringify(jobs)])\n\n    return (rows.length) ? rows.map((i): string => i.id) : null\n  }\n\n  getDebounceStartAfter (singletonSeconds: number, clockOffset: number) {\n    const debounceInterval = singletonSeconds * 1000\n\n    const now = Date.now() + clockOffset\n\n    const slot = Math.floor(now / debounceInterval) * debounceInterval\n\n    // prevent startAfter=0 during debouncing\n    let startAfter = (singletonSeconds - Math.floor((now - slot) / 1000)) || 1\n\n    if (singletonSeconds > 1) {\n      startAfter++\n    }\n\n    return startAfter\n  }\n\n  fetch<T>(name: string): Promise<types.Job<T>[]>\n  fetch<T>(name: string, options: types.FetchOptions & { includeMetadata: true }): Promise<types.JobWithMetadata<T>[]>\n  fetch<T>(name: string, options: types.FetchOptions): Promise<types.Job<T>[]>\n  async fetch (name: string, options: types.FetchOptions = {}) {\n    Attorney.checkFetchArgs(name, options)\n\n    const db = this.assertDb(options)\n\n    const { table, policy, singletonsActive } = await this.getQueueCache(name)\n\n    const fetchOptions = {\n      ...options,\n      schema: this.config.schema,\n      table,\n      name,\n      policy,\n      limit: options.batchSize!,\n      ignoreSingletons: singletonsActive\n    }\n\n    const sql = plans.fetchNextJob(fetchOptions)\n\n    let result\n\n    try {\n      result = await db.executeSql(sql)\n    } catch (err) {\n      // errors from fetchquery should only be unique constraint violations\n    }\n\n    return result?.rows || []\n  }\n\n  private mapCompletionIdArg (id: string | string[], funcName: string) {\n    const errorMessage = `${funcName}() requires an id`\n\n    assert(id, errorMessage)\n\n    const ids = Array.isArray(id) ? id : [id]\n\n    assert(ids.length, errorMessage)\n\n    return ids\n  }\n\n  private mapCompletionDataArg (data: object | undefined) {\n    if (data === null || typeof data === 'undefined' || typeof data === 'function') { return null }\n\n    const result = (typeof data === 'object' && !Array.isArray(data))\n      ? data\n      : { value: data }\n\n    return stringify(result)\n  }\n\n  private mapCommandResponse (ids: string[], result: { rows: any[] } | null): types.CommandResponse {\n    return {\n      jobs: ids,\n      requested: ids.length,\n      affected: result && result.rows ? parseInt(result.rows[0].count) : 0\n    }\n  }\n\n  async complete (name: string, id: string | string[], data?: object, options: types.ConnectionOptions = {}) {\n    Attorney.assertQueueName(name)\n    const db = this.assertDb(options)\n    const ids = this.mapCompletionIdArg(id, 'complete')\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.completeJobs(this.config.schema, table)\n    const result = await db.executeSql(sql, [name, ids, this.mapCompletionDataArg(data)])\n    return this.mapCommandResponse(ids, result)\n  }\n\n  async fail (name: string, id: string | string[], data?: any, options: types.ConnectionOptions = {}) {\n    Attorney.assertQueueName(name)\n    const db = this.assertDb(options)\n    const ids = this.mapCompletionIdArg(id, 'fail')\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.failJobsById(this.config.schema, table)\n    const result = await db.executeSql(sql, [name, ids, this.mapCompletionDataArg(data)])\n    return this.mapCommandResponse(ids, result)\n  }\n\n  async cancel (name: string, id: string | string[], options: types.ConnectionOptions = {}) {\n    Attorney.assertQueueName(name)\n    const db = this.assertDb(options)\n    const ids = this.mapCompletionIdArg(id, 'cancel')\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.cancelJobs(this.config.schema, table)\n    const result = await db.executeSql(sql, [name, ids])\n    return this.mapCommandResponse(ids, result)\n  }\n\n  async deleteJob (name: string, id: string | string[], options: types.ConnectionOptions = {}) {\n    Attorney.assertQueueName(name)\n    const db = this.assertDb(options)\n    const ids = this.mapCompletionIdArg(id, 'deleteJob')\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.deleteJobsById(this.config.schema, table)\n    const result = await db.executeSql(sql, [name, ids])\n    return this.mapCommandResponse(ids, result)\n  }\n\n  async resume (name: string, id: string | string[], options: types.ConnectionOptions = {}) {\n    Attorney.assertQueueName(name)\n    const db = this.assertDb(options)\n    const ids = this.mapCompletionIdArg(id, 'resume')\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.resumeJobs(this.config.schema, table)\n    const result = await db.executeSql(sql, [name, ids])\n    return this.mapCommandResponse(ids, result)\n  }\n\n  async retry (name: string, id: string | string[], options: types.ConnectionOptions = {}) {\n    Attorney.assertQueueName(name)\n    const db = options.db || this.db\n    const ids = this.mapCompletionIdArg(id, 'retry')\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.retryJobs(this.config.schema, table)\n    const result = await db.executeSql(sql, [name, ids])\n    return this.mapCommandResponse(ids, result)\n  }\n\n  async createQueue (name: string, options: Omit<types.Queue, 'name'> & { name?: string } = {}) {\n    name = name || options.name!\n\n    Attorney.assertQueueName(name)\n\n    options.policy = options.policy || plans.QUEUE_POLICIES.standard\n\n    assert(options.policy in plans.QUEUE_POLICIES, `${options.policy} is not a valid queue policy`)\n\n    Attorney.validateQueueArgs(options)\n\n    if (options.deadLetter) {\n      Attorney.assertQueueName(options.deadLetter)\n      notStrictEqual(name, options.deadLetter, 'deadLetter cannot be itself')\n      await this.getQueueCache(options.deadLetter)\n    }\n\n    const sql = plans.createQueue(this.config.schema, name, options)\n    await this.db.executeSql(sql)\n  }\n\n  async getQueues (names?: string | string[]): Promise<types.QueueResult[]> {\n    names = Array.isArray(names) ? names : typeof names === 'string' ? [names] : undefined\n    if (names) {\n      for (const name of names) {\n        Attorney.assertQueueName(name)\n      }\n    }\n\n    const sql = plans.getQueues(this.config.schema, names)\n    const { rows } = await this.db.executeSql(sql)\n    return rows\n  }\n\n  async updateQueue (name: string, options: types.UpdateQueueOptions = {}) {\n    Attorney.assertQueueName(name)\n\n    assert(Object.keys(options).length > 0, 'no properties found to update')\n\n    if ('policy' in options) {\n      throw new Error('queue policy cannot be changed after creation')\n    }\n\n    if ('partition' in options) {\n      throw new Error('queue partitioning cannot be changed after creation')\n    }\n\n    Attorney.validateQueueArgs(options)\n\n    const { deadLetter } = options\n\n    if (deadLetter) {\n      Attorney.assertQueueName(deadLetter)\n      notStrictEqual(name, deadLetter, 'deadLetter cannot be itself')\n    }\n\n    const sql = plans.updateQueue(this.config.schema, { deadLetter })\n    await this.db.executeSql(sql, [name, options])\n  }\n\n  async getQueue (name: string) {\n    Attorney.assertQueueName(name)\n\n    const sql = plans.getQueues(this.config.schema, [name])\n    const { rows } = await this.db.executeSql(sql)\n\n    return rows[0] || null\n  }\n\n  async deleteQueue (name: string) {\n    Attorney.assertQueueName(name)\n\n    try {\n      await this.getQueueCache(name)\n      const sql = plans.deleteQueue(this.config.schema, name)\n      await this.db.executeSql(sql)\n    } catch { }\n  }\n\n  async deleteQueuedJobs (name: string) {\n    Attorney.assertQueueName(name)\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.deleteQueuedJobs(this.config.schema, table)\n    await this.db.executeSql(sql, [name])\n  }\n\n  async deleteStoredJobs (name: string) {\n    Attorney.assertQueueName(name)\n    const { table } = await this.getQueueCache(name)\n    const sql = plans.deleteStoredJobs(this.config.schema, table)\n    await this.db.executeSql(sql, [name])\n  }\n\n  async deleteAllJobs (name: string) {\n    Attorney.assertQueueName(name)\n    const { table, partition } = await this.getQueueCache(name)\n\n    if (partition) {\n      const sql = plans.truncateTable(this.config.schema, table)\n      await this.db.executeSql(sql)\n    } else {\n      const sql = plans.deleteAllJobs(this.config.schema, table)\n      await this.db.executeSql(sql, [name])\n    }\n  }\n\n  async getQueueStats (name: string) {\n    Attorney.assertQueueName(name)\n\n    const queue = await this.getQueueCache(name)\n\n    const sql = plans.getQueueStats(this.config.schema, queue.table, [name])\n\n    const { rows } = await this.db.executeSql(sql)\n\n    return Object.assign(queue, rows.at(0) || {})\n  }\n\n  async getJobById<T>(name: string, id: string, options: types.ConnectionOptions = {}): Promise<types.JobWithMetadata<T> | null> {\n    Attorney.assertQueueName(name)\n\n    const db = this.assertDb(options)\n\n    const { table } = await this.getQueueCache(name)\n\n    const sql = plans.getJobById(this.config.schema, table)\n\n    const result1 = await db.executeSql(sql, [name, id])\n\n    if (result1?.rows?.length === 1) {\n      return result1.rows[0]\n    } else {\n      return null\n    }\n  }\n\n  private assertDb (options: types.ConnectionOptions) {\n    if (options.db) {\n      return options.db\n    }\n\n    if (this.db._pgbdb) {\n      assert(this.db.opened, 'Database connection is not opened')\n    }\n\n    return this.db\n  }\n}\n\nexport default Manager\n","import EventEmitter from 'node:events'\nimport type Manager from './manager.js'\nimport * as plans from './plans.js'\nimport { unwrapSQLResult } from './tools.js'\nimport * as types from './types.js'\n\nconst events = {\n  error: 'error',\n  warning: 'warning'\n}\n\nconst WARNINGS = {\n  SLOW_QUERY: { seconds: 30, message: 'Warning: slow query. Your queues and/or database server should be reviewed' },\n  LARGE_QUEUE: { size: 10_000, message: 'Warning: large queue backlog. Your queue should be reviewed' }\n}\n\nclass Boss extends EventEmitter implements types.EventsMixin {\n  #stopped: boolean\n  #maintaining: boolean | undefined\n  #superviseInterval: NodeJS.Timeout | undefined\n  #db: types.IDatabase\n  #config: types.ResolvedConstructorOptions\n  #manager: Manager\n\n  events = events\n\n  constructor (\n    db: types.IDatabase,\n    manager: Manager,\n    config: types.ResolvedConstructorOptions\n  ) {\n    super()\n\n    this.#db = db\n    this.#config = config\n    this.#manager = manager\n    this.#stopped = true\n\n    if (config.warningSlowQuerySeconds) {\n      WARNINGS.SLOW_QUERY.seconds = config.warningSlowQuerySeconds\n    }\n\n    if (config.warningQueueSize) {\n      WARNINGS.LARGE_QUEUE.size = config.warningQueueSize\n    }\n  }\n\n  async start () {\n    if (this.#stopped) {\n      this.#superviseInterval = setInterval(\n        () => this.#onSupervise(),\n        this.#config.superviseIntervalSeconds! * 1000\n      )\n      this.#stopped = false\n    }\n  }\n\n  async stop () {\n    if (!this.#stopped) {\n      if (this.#superviseInterval) clearInterval(this.#superviseInterval)\n      this.#stopped = true\n    }\n  }\n\n  async #executeSql (sql: string, values?: unknown[]) {\n    const started = Date.now()\n\n    const result = unwrapSQLResult(await this.#db.executeSql(sql, values))\n\n    const ended = Date.now()\n\n    const elapsed = (ended - started) / 1000\n\n    if (\n      elapsed > WARNINGS.SLOW_QUERY.seconds ||\n      this.#config.__test__warn_slow_query\n    ) {\n      this.emit(events.warning, {\n        message: WARNINGS.SLOW_QUERY.message,\n        data: { elapsed, sql, values },\n      })\n    }\n\n    return result\n  }\n\n  async #onSupervise () {\n    try {\n      if (this.#stopped) return\n      if (this.#maintaining) return\n      if (this.#config.__test__throw_maint) { throw new Error(this.#config.__test__throw_maint) }\n\n      this.#maintaining = true\n\n      const queues = await this.#manager.getQueues()\n\n      for (const queue of queues) {\n        !this.#stopped && (await this.supervise(queue))\n      }\n    } catch (err) {\n      this.emit(events.error, err)\n    } finally {\n      this.#maintaining = false\n    }\n  }\n\n  async supervise (value?: string | types.QueueResult) {\n    let queues\n\n    if (typeof value === 'object') {\n      queues = [value]\n    } else {\n      queues = await this.#manager.getQueues(value)\n    }\n\n    const queueGroups = queues.reduce<\n      Record<string, { table: string; queues: types.Queue[] }>\n    >((acc, q) => {\n      const { table } = q\n      acc[table] = acc[table] || { table, queues: [] }\n      acc[table].queues.push(q)\n      return acc\n    }, {})\n\n    for (const queueGroup of Object.values(queueGroups)) {\n      const { table, queues } = queueGroup\n      const names = queues.map((i) => i.name)\n\n      while (names.length) {\n        const chunk = names.splice(0, 100)\n\n        await this.#monitor(table, chunk)\n        await this.#maintain(table, chunk)\n      }\n    }\n  }\n\n  async #monitor (table: string, names: string[]) {\n    const command = plans.trySetQueueMonitorTime(\n      this.#config.schema,\n      names,\n      this.#config.monitorIntervalSeconds\n    )\n    const { rows } = await this.#executeSql(command)\n\n    if (rows.length) {\n      const queues = rows.map((q) => q.name)\n\n      const cacheStatsSql = plans.cacheQueueStats(this.#config.schema, table, queues)\n      const { rows: rowsCacheStats } = await this.#executeSql(cacheStatsSql)\n      const warnings = rowsCacheStats.filter(i => i.queuedCount > (i.warningQueueSize || WARNINGS.LARGE_QUEUE.size))\n\n      for (const warning of warnings) {\n        this.emit(events.warning, {\n          message: WARNINGS.LARGE_QUEUE.message,\n          data: warning,\n        })\n      }\n\n      const sql = plans.failJobsByTimeout(this.#config.schema, table, queues)\n      await this.#executeSql(sql)\n    }\n  }\n\n  async #maintain (table: string, names: string[]) {\n    const command = plans.trySetQueueDeletionTime(\n      this.#config.schema,\n      names,\n      this.#config.maintenanceIntervalSeconds\n    )\n    const { rows } = await this.#executeSql(command)\n\n    if (rows.length) {\n      const queues = rows.map((q) => q.name)\n      const sql = plans.deletion(this.#config.schema, table, queues)\n      await this.#executeSql(sql)\n    }\n  }\n}\n\nexport default Boss\n","import EventEmitter from 'node:events'\nimport pg from 'pg'\nimport assert from 'node:assert'\nimport type * as types from './types.ts'\n\nclass Db extends EventEmitter implements types.IDatabase, types.EventsMixin {\n  private pool!: pg.Pool\n  private config: types.DatabaseOptions\n  /** @internal */\n  readonly _pgbdb: true\n  opened: boolean\n\n  constructor (config: types.DatabaseOptions) {\n    super()\n\n    config.application_name = config.application_name || 'pgboss'\n    // config.maxUses = config.maxUses || 1000\n\n    this.config = config\n    this._pgbdb = true\n    this.opened = false\n  }\n\n  events = {\n    error: 'error'\n  }\n\n  async open () {\n    this.pool = new pg.Pool(this.config)\n    this.pool.on('error', error => this.emit('error', error))\n    this.opened = true\n  }\n\n  async close () {\n    if (!this.pool.ending) {\n      this.opened = false\n      await this.pool.end()\n    }\n  }\n\n  async executeSql (text: string, values?: unknown[]) {\n    assert(this.opened, 'Database not opened. Call open() before executing SQL.')\n\n    // if (this.config.debug === true) {\n    //   console.log(`${new Date().toISOString()}: DEBUG SQL`)\n    //   console.log(text)\n\n    //   if (values) {\n    //     console.log(`${new Date().toISOString()}: DEBUG VALUES`)\n    //     console.log(values)\n    //   }\n    // }\n\n    return await this.pool.query(text, values)\n  }\n}\n\nexport default Db\n","import EventEmitter from 'node:events'\nimport * as Attorney from './attorney.ts'\nimport Contractor from './contractor.ts'\nimport Manager from './manager.ts'\nimport Timekeeper from './timekeeper.ts'\nimport Boss from './boss.ts'\nimport { delay } from './tools.ts'\nimport type * as types from './types.ts'\nimport DbDefault from './db.ts'\n\nexport { JOB_STATES as states } from './plans.ts'\nexport { QUEUE_POLICIES as policies } from './plans.ts'\nexport const events: types.Events = Object.freeze({\n  error: 'error',\n  warning: 'warning',\n  wip: 'wip',\n  stopped: 'stopped'\n})\n\nexport function getConstructionPlans (schema?: string) {\n  return Contractor.constructionPlans(schema)\n}\n\nexport function getMigrationPlans (schema?: string, version?: number) {\n  return Contractor.migrationPlans(schema, version)\n}\n\nexport function getRollbackPlans (schema?: string, version?: number) {\n  return Contractor.rollbackPlans(schema, version)\n}\n\nexport class PgBoss extends EventEmitter<types.PgBossEventMap> {\n  #stoppingOn: number | null\n  #stopped: boolean\n  #starting: boolean | undefined\n  #started: boolean | undefined\n  #config: types.ResolvedConstructorOptions\n  #db: (types.IDatabase & { _pgbdb?: false }) | DbDefault\n  #boss: Boss\n  #contractor: Contractor\n  #manager: Manager\n  #timekeeper: Timekeeper\n\n  constructor (connectionString: string)\n  constructor (options: types.ConstructorOptions)\n  constructor (value: string | types.ConstructorOptions) {\n    super()\n    this.#stoppingOn = null\n    this.#stopped = true\n\n    const config = Attorney.getConfig(value)\n    this.#config = config\n\n    const db: (types.IDatabase & { _pgbdb?: false }) | DbDefault = this.getDb()\n    this.#db = db\n\n    if ('_pgbdb' in this.#db && this.#db._pgbdb) {\n      this.#promoteEvents(this.#db)\n    }\n\n    const contractor = new Contractor(db, config)\n\n    const manager = new Manager(db, config)\n\n    const boss = new Boss(db, manager, config)\n\n    const timekeeper = new Timekeeper(db, manager, config)\n    manager.timekeeper = timekeeper\n\n    this.#promoteEvents(manager)\n    this.#promoteEvents(boss)\n    this.#promoteEvents(timekeeper)\n\n    this.#boss = boss\n    this.#contractor = contractor\n    this.#manager = manager\n    this.#timekeeper = timekeeper\n  }\n\n  #promoteEvents (emitter: types.EventsMixin) {\n    for (const event of Object.values(emitter?.events) as (keyof types.PgBossEventMap)[]) {\n      emitter.on(event, arg => this.emit(event, arg))\n    }\n  }\n\n  async start (): Promise<this> {\n    if (this.#starting || this.#started) {\n      return this\n    }\n\n    this.#starting = true\n\n    if (this.#db._pgbdb && !this.#db.opened) {\n      await this.#db.open()\n    }\n\n    if (this.#config.migrate) {\n      await this.#contractor.start()\n    } else {\n      await this.#contractor.check()\n    }\n\n    await this.#manager.start()\n\n    if (this.#config.supervise) {\n      await this.#boss.start()\n    }\n\n    if (this.#config.schedule) {\n      await this.#timekeeper.start()\n    }\n\n    this.#starting = false\n    this.#started = true\n    this.#stopped = false\n\n    return this\n  }\n\n  async stop (options: types.StopOptions = {}): Promise<void> {\n    if (this.#stoppingOn || this.#stopped) {\n      return\n    }\n\n    let { close = true, graceful = true, timeout = 30000 } = options\n\n    timeout = Math.max(timeout, 1000)\n\n    this.#stoppingOn = Date.now()\n\n    await this.#manager.stop()\n    await this.#timekeeper.stop()\n    await this.#boss.stop()\n\n    const shutdown = async () => {\n      await this.#manager.failWip()\n\n      if (this.#db._pgbdb && this.#db.opened && close) {\n        await this.#db.close()\n      }\n\n      this.#stopped = true\n      this.#stoppingOn = null\n      this.#started = false\n\n      this.emit(events.stopped)\n    }\n\n    if (!graceful) {\n      return await shutdown()\n    }\n\n    const isWip = () => this.#manager.getWipData({ includeInternal: false }).length > 0\n\n    while ((Date.now() - this.#stoppingOn!) < timeout && isWip()) {\n      await delay(500)\n    }\n\n    await shutdown()\n  }\n\n  send (request: types.Request): Promise<string | null>\n  send (name: string, data?: object | null, options?: types.SendOptions): Promise<string | null>\n  async send (...args: any[]): Promise<string | null> {\n    return await this.#manager.send(...args as Parameters<Manager['send']>)\n  }\n\n  sendAfter (name: string, data: object, options: types.SendOptions, date: Date): Promise<string | null>\n  sendAfter (name: string, data: object, options: types.SendOptions, dateString: string): Promise<string | null>\n  sendAfter (name: string, data: object, options: types.SendOptions, seconds: number): Promise<string | null>\n  async sendAfter (name: string, data: object, options: types.SendOptions, after: Date | string | number): Promise<string | null> {\n    return this.#manager.sendAfter(name, data, options, after)\n  }\n\n  sendThrottled (name: string, data: object, options: types.SendOptions, seconds: number, key?: string): Promise<string | null> {\n    return this.#manager.sendThrottled(name, data, options, seconds, key)\n  }\n\n  sendDebounced (name: string, data: object, options: types.SendOptions, seconds: number, key?: string): Promise<string | null> {\n    return this.#manager.sendDebounced(name, data, options, seconds, key)\n  }\n\n  insert (name: string, jobs: types.JobInsert[], options?: types.InsertOptions): Promise<string[] | null> {\n    return this.#manager.insert(name, jobs, options)\n  }\n\n  fetch<T>(name: string, options: types.FetchOptions & { includeMetadata: true }): Promise<types.JobWithMetadata<T>[]>\n  fetch<T>(name: string, options?: types.FetchOptions): Promise<types.Job<T>[]>\n  fetch<T>(name: string, options: types.FetchOptions = {}): Promise<types.Job<T>[] | types.JobWithMetadata<T>[]> {\n    return this.#manager.fetch<T>(name, options)\n  }\n\n  work<ReqData>(name: string, handler: types.WorkHandler<ReqData>): Promise<string>\n  work<ReqData>(name: string, options: types.WorkOptions & { includeMetadata: true }, handler: types.WorkWithMetadataHandler<ReqData>): Promise<string>\n  work<ReqData>(name: string, options: types.WorkOptions, handler: types.WorkHandler<ReqData>): Promise<string>\n  work (...args: any[]): Promise<string> {\n    return this.#manager.work(...args as Parameters<Manager['work']>)\n  }\n\n  offWork (name: string): Promise<void>\n  offWork (options: types.OffWorkOptions): Promise<void>\n  offWork (value: string | types.OffWorkOptions): Promise<void> {\n    return this.#manager.offWork(value)\n  }\n\n  notifyWorker (workerId: string): void {\n    this.#manager.notifyWorker(workerId)\n  }\n\n  subscribe (event: string, name: string): Promise<void> {\n    return this.#manager.subscribe(event, name)\n  }\n\n  unsubscribe (event: string, name: string): Promise<void> {\n    return this.#manager.unsubscribe(event, name)\n  }\n\n  publish (event: string, data?: object, options?: types.SendOptions): Promise<void> {\n    return this.#manager.publish(event, data, options)\n  }\n\n  cancel (name: string, id: string | string[], options?: types.ConnectionOptions): Promise<types.CommandResponse> {\n    return this.#manager.cancel(name, id, options)\n  }\n\n  resume (name: string, id: string | string[], options?: types.ConnectionOptions): Promise<types.CommandResponse> {\n    return this.#manager.resume(name, id, options)\n  }\n\n  retry (name: string, id: string | string[], options?: types.ConnectionOptions): Promise<types.CommandResponse> {\n    return this.#manager.retry(name, id, options)\n  }\n\n  deleteJob (name: string, id: string | string[], options?: types.ConnectionOptions): Promise<types.CommandResponse> {\n    return this.#manager.deleteJob(name, id, options)\n  }\n\n  deleteQueuedJobs (name: string): Promise<void> {\n    return this.#manager.deleteQueuedJobs(name)\n  }\n\n  deleteStoredJobs (name: string): Promise<void> {\n    return this.#manager.deleteStoredJobs(name)\n  }\n\n  deleteAllJobs (name: string): Promise<void> {\n    return this.#manager.deleteAllJobs(name)\n  }\n\n  complete (name: string, id: string | string[], data?: object, options?: types.ConnectionOptions): Promise<types.CommandResponse> {\n    return this.#manager.complete(name, id, data, options)\n  }\n\n  fail (name: string, id: string | string[], data?: object, options?: types.ConnectionOptions): Promise<types.CommandResponse> {\n    return this.#manager.fail(name, id, data, options)\n  }\n\n  getJobById<T>(name: string, id: string, options?: types.ConnectionOptions): Promise<types.JobWithMetadata<T> | null> {\n    return this.#manager.getJobById<T>(name, id, options)\n  }\n\n  createQueue (name: string, options?: Omit<types.Queue, 'name'>): Promise<void> {\n    return this.#manager.createQueue(name, options)\n  }\n\n  updateQueue (name: string, options?: types.UpdateQueueOptions): Promise<void> {\n    return this.#manager.updateQueue(name, options)\n  }\n\n  deleteQueue (name: string): Promise<void> {\n    return this.#manager.deleteQueue(name)\n  }\n\n  getQueues (names?: string[]): Promise<types.QueueResult[]> {\n    return this.#manager.getQueues()\n  }\n\n  getQueue (name: string): Promise<types.QueueResult | null> {\n    return this.#manager.getQueue(name)\n  }\n\n  getQueueStats (name: string): Promise<types.QueueResult> {\n    return this.#manager.getQueueStats(name)\n  }\n\n  supervise (name?: string): Promise<void> {\n    return this.#boss.supervise(name)\n  }\n\n  isInstalled (): Promise<boolean> {\n    return this.#contractor.isInstalled()\n  }\n\n  schemaVersion (): Promise<number | null> {\n    return this.#contractor.schemaVersion()\n  }\n\n  schedule (name: string, cron: string, data?: object, options?: types.ScheduleOptions): Promise<void> {\n    return this.#timekeeper.schedule(name, cron, data, options)\n  }\n\n  unschedule (name: string, key?: string): Promise<void> {\n    return this.#timekeeper.unschedule(name, key)\n  }\n\n  getSchedules (name?: string, key?: string): Promise<types.Schedule[]> {\n    return this.#timekeeper.getSchedules(name, key)\n  }\n\n  getDb (): types.IDatabase {\n    if (this.#db) {\n      return this.#db\n    }\n\n    if (this.#config.db) {\n      return this.#config.db\n    }\n\n    return new DbDefault(this.#config)\n  }\n}\n\nexport type {\n  ConnectionOptions,\n  ConstructorOptions,\n  FetchOptions,\n  IDatabase as Db,\n  Job,\n  JobFetchOptions,\n  JobInsert,\n  JobPollingOptions,\n  JobStates,\n  Events,\n  JobWithMetadata,\n  MaintenanceOptions,\n  OffWorkOptions,\n  Queue,\n  QueuePolicy,\n  QueueResult,\n  Request,\n  Schedule,\n  ScheduleOptions,\n  SchedulingOptions,\n  SendOptions,\n  StopOptions,\n  WipData,\n  WorkHandler,\n  WorkOptions,\n  WorkWithMetadataHandler,\n} from './types.ts'\n"],"mappings":"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"}